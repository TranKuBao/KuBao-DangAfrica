{% extends "layouts/base.html" %}

{% block content %}
<div class="container-fluid py-4">
  <div class="row">
    <div class="col-12">
      <!-- Header thông tin shell -->
      <div class="card mb-4">
        <div class="card-header pb-0 d-flex flex-wrap justify-content-between align-items-center">
          <div>
            <h5 class="mb-1">Shell Detail</h5>
            <div class="d-flex flex-wrap gap-3 align-items-center">
              <span class="badge bg-dark">Session: {{ shell.connection_id }}</span>
              <span class="badge bg-info">Type: {{ shell.shell_type.name }}</span>
              <span class="badge bg-secondary">Status: {{ shell.status.name }}</span>
              <span class="badge bg-success">User: {{ shell.user or 'N/A' }}</span>
              <span class="badge bg-warning text-dark">Privilege: {{ shell.privilege_level or 'N/A' }}</span>
            </div>
          </div>
          <div class="text-end">
            <div class="mb-1">
              <i class="fas fa-calendar-alt me-1"></i> Created: {{ shell.created_at|replace('T', ' ')|truncate(19, True, '') if shell.created_at }}
            </div>
            <div>
              <i class="fas fa-clock me-1"></i> Updated: {{ shell.updated_at|replace('T', ' ')|truncate(19, True, '') if shell.updated_at }}
            </div>
          </div>
        </div>
        <div class="card-body py-2">
          <div class="row g-3">
            <div class="col-md-4">
              <div class="border rounded p-3 h-100">
                <h6 class="mb-2"><i class="fas fa-network-wired me-1"></i> Listen (Local)</h6>
                <div><strong>IP:</strong> {{ shell.local_ip or 'N/A' }}</div>
                <div><strong>Port:</strong> {{ shell.local_port or 'N/A' }}</div>
              </div>
            </div>
            <div class="col-md-4">
              <div class="border rounded p-3 h-100">
                <h6 class="mb-2"><i class="fas fa-globe me-1"></i> Remote</h6>
                <div><strong>IP:</strong> {{ shell.remote_ip or 'N/A' }}</div>
                <div><strong>Port:</strong> {{ shell.remote_port or 'N/A' }}</div>
              </div>
            </div>
            <div class="col-md-4">
              <div class="border rounded p-3 h-100">
                <h6 class="mb-2"><i class="fas fa-bullseye me-1"></i> Linked Target</h6>
                <div id="linkedTargetInfo">
                  {% if shell.target_id and shell.target_id|int > 0 %}
                    <div><strong>Hostname:</strong> <span id="linkedTargetHostname">{{ shell.hostname or 'N/A' }}</span></div>
                    <div><strong>Target ID:</strong> <a href="/targets/{{ shell.target_id }}" target="_blank" id="linkedTargetId">{{ shell.target_id }}</a></div>
                  {% else %}
                    <div class="text-muted">No target linked</div>
                  {% endif %}
                </div>
                <!-- Khu vực cập nhật liên kết target -->
                <div class="mt-2">
                  <select id="targetSelect" class="form-select form-select-sm mb-1">
                    <option value="">-- Chọn target để liên kết --</option>
                    {% for t in targets %}
                      <option value="{{ t.server_id }}" {% if shell.target_id==t.server_id %}selected{% endif %}>{{ t.hostname }} ({{ t.ip_address }})</option>
                    {% endfor %}
                  </select>
                  <button class="btn btn-sm btn-outline-primary" id="updateTargetBtn">Cập nhật liên kết</button>
                  <span id="updateTargetStatus" class="ms-2 text-success" style="display:none;"></span>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <!-- Ghi chú cho shell -->
      <div class="card mb-4">
        <div class="card-header pb-0 d-flex align-items-center justify-content-between">
          <h6 class="mb-0"><i class="fas fa-sticky-note me-2"></i>Shell Notes</h6>
          <button class="btn btn-sm btn-outline-primary" id="saveNoteBtn"><i class="fas fa-save me-1"></i>Save Note</button>
        </div>
        <div class="card-body">
          <textarea id="shellNote" class="form-control" rows="3" >{{ shell.notes or '' }}</textarea>
          <div id="noteStatus" class="mt-2 text-success" style="display:none;"></div>
        </div>
      </div>
      <!-- Terminal tương tác trực tiếp -->
      <div class="card mb-4">
        <div class="card-header pb-0 d-flex align-items-center justify-content-between">
          <h6 class="mb-0"><i class="fas fa-terminal me-2"></i>Interactive Shell</h6>
          <span id="shellStatus" class="badge bg-secondary ms-2">Disconnected</span>
        </div>
        <div class="card-body p-0">
          <div class="shell-container">
            <div class="terminal-header">
              <div class="terminal-controls">
                <span class="control close"></span>
                <span class="control minimize"></span>
                <span class="control maximize"></span>
              </div>
              <div class="terminal-title">
                <i class="fas fa-server me-2"></i>
                <span id="targetInfo">Target: {{ shell.hostname or shell_name or shell_id }}</span>
              </div>
            </div>
            <!-- Terminal output area -->
            <div class="terminal-body" id="terminalOutput">
              <div class="terminal-content" id="terminalContent">
                <div class="terminal-line">
                  
                  <span class="command" id="currentCommand"></span>
                </div>
              </div>
            </div>
            <!-- Terminal input area -->
            <div class="terminal-input-area" id="terminalInputArea">
              <div class="terminal-line" id="currentInputLine">
                <span class="prompt" id="currentPrompt"></span>
                <span class="command-input" id="commandInput" contenteditable="true" spellcheck="false"></span>
                
              </div>
            </div>
            <div class="p-2 d-flex gap-2">
              <button type="button" class="btn btn-outline-secondary btn-sm" id="clearTerminal">
                <i class="fas fa-trash me-1"></i>Clear
              </button>
              <button type="button" class="btn btn-outline-secondary btn-sm" id="saveOutput">
                <i class="fas fa-save me-1"></i>Save
              </button>
              <button type="button" class="btn btn-outline-secondary btn-sm" id="fullscreen">
                <i class="fas fa-expand me-1"></i>Fullscreen
              </button>
              <button type="button" class="btn btn-outline-info btn-sm" id="loadHistory">
                <i class="fas fa-history me-1"></i>History
              </button>
              <!-- Nút debug terminal state -->
              <button type="button" class="btn btn-outline-secondary btn-sm" id="debugTerminal" onclick="debugTerminalState()">
                <i class="fas fa-bug me-1"></i>Debug
              </button>
              <!-- Nút force sync shell status -->
              <button type="button" class="btn btn-outline-info btn-sm" id="forceSyncBtn" onclick="forceSyncShellStatus()">
                <i class="fas fa-sync me-1"></i>Force Sync
              </button>
              <!-- Nút bật/tắt shell -->
              <button type="button" class="btn btn-outline-warning btn-sm" id="toggleShellBtn">
                <i class="fas fa-power-off me-1"></i><span id="toggleShellBtnText">Tắt Shell</span>
              </button>
              <!-- Nút đóng shell hoàn toàn -->
              <button type="button" class="btn btn-outline-danger btn-sm" id="closeShellBtn" onclick="closeShellCompletely()">
                <i class="fas fa-times-circle me-1"></i>Close Shell
              </button>
              <button type="button" class="btn btn-danger btn-sm ms-auto" id="disconnectShell" disabled>
                <i class="fas fa-times me-1"></i>Disconnect
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<style>
.shell-container {
  background: #1e1e1e;
  border-radius: 8px;
  overflow: hidden;
  font-family: 'Courier New', monospace;
  height: 500px;
  display: flex;
  flex-direction: column;
}
.terminal-header {
  background: #2d2d2d;
  padding: 8px 15px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  border-bottom: 1px solid #404040;
}
.terminal-controls { display: flex; gap: 8px; }
.control { width: 12px; height: 12px; border-radius: 50%; cursor: pointer; }
.control.close { background: #ff5f56; }
.control.minimize { background: #ffbd2e; }
.control.maximize { background: #27ca3f; }
.terminal-title { color: #ffffff; font-size: 14px; font-weight: 500; }
.terminal-body { 
  flex: 1; 
  padding: 15px; 
  overflow-y: auto; 
  background: #1e1e1e; 
  color: #ffffff; 
  font-size: 14px; 
  line-height: 1.4; 
  max-height: 300px;
}
.terminal-content { min-height: 100%; }
.terminal-line { margin-bottom: 5px; display: flex; align-items: center; }
.prompt { color: #4CAF50; font-weight: bold; margin-right: 10px; white-space: nowrap; }
.command { color: #ffffff; flex: 1; }
.cursor { color: #ffffff; animation: blink 1s infinite; margin-left: 2px; }
@keyframes blink { 0%, 50% { opacity: 1; } 51%, 100% { opacity: 0; } }
.output-line { color: #cccccc; margin-bottom: 5px; word-wrap: break-word; }
.error-line { color: #ff6b6b; }
.success-line { color: #4CAF50; }
.terminal-input-area { 
  padding: 15px; 
  background: #1e1e1e; 
  border-top: 1px solid #404040; 
}
.terminal-input-area .terminal-line {
  display: flex;
  align-items: center;
  background: transparent;
  border: none;
  padding: 0;
  margin: 0;
}
.command-input {
  flex: 1;
  background: transparent;
  border: none;
  color: #ffffff;
  font-family: 'Courier New', monospace;
  font-size: 14px;
  outline: none;
  min-height: 20px;
  white-space: pre-wrap;
  word-wrap: break-word;
  overflow-wrap: break-word;
}
.command-input:focus {
  background: transparent;
  border: none;
  color: #ffffff;
  box-shadow: none;
}
.command-input[contenteditable="true"]:empty:before {
  content: '';
}
.terminal-body::-webkit-scrollbar { width: 8px; }
.terminal-body::-webkit-scrollbar-track { background: #2d2d2d; }
.terminal-body::-webkit-scrollbar-thumb { background: #404040; border-radius: 4px; }
.terminal-body::-webkit-scrollbar-thumb:hover { background: #555555; }
.terminal-line { animation: slideIn 0.3s ease; }
@keyframes slideIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
#shellStatus { animation: pulse 2s infinite; }
@keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.7; } 100% { opacity: 1; } }
.shell-container.fullscreen { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 9999; border-radius: 0; }

/* Terminal thật styling */
.terminal-line {
  position: relative;
  min-height: 20px;
  line-height: 1.4;
}

.command-input {
  position: relative;
  display: inline-block;
  min-width: 1px;
}

.command-input:focus {
  outline: none;
}

/* Cursor animation */
.cursor {
  animation: blink 1s infinite;
  font-weight: bold;
}

@keyframes blink {
  0%, 50% { opacity: 1; }
  51%, 100% { opacity: 0; }
}

/* Selection styling */
.command-input::selection {
  background: #4CAF50;
  color: #ffffff;
}

.command-input::-moz-selection {
  background: #4CAF50;
  color: #ffffff;
}

/* Terminal font */
.terminal-body, .command-input {
  font-family: 'Courier New', 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
  font-size: 14px;
  line-height: 1.4;
}

/* Responsive terminal */
@media (max-width: 768px) {
  .terminal-body, .command-input {
    font-size: 12px;
  }
  
  .shell-container {
    height: 400px;
  }
}

/* Terminal colors */
.prompt { color: #4CAF50; font-weight: bold; }
.command { color: #ffffff; }
.output-line { color: #cccccc; }
.error-line { color: #ff6b6b; }
.success-line { color: #4CAF50; }
.warning-line { color: #ffa726; }
.info-line { color: #42a5f5; }

/* Auto-completion styles */
.command-suggestions {
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  background: #2d2d2d;
  border: 1px solid #404040;
  border-top: none;
  max-height: 200px;
  overflow-y: auto;
  z-index: 1000;
  display: none;
}

.suggestion-item {
  padding: 8px 12px;
  color: #ffffff;
  cursor: pointer;
  border-bottom: 1px solid #404040;
  font-family: 'Courier New', monospace;
  font-size: 14px;
}

.suggestion-item:hover {
  background: #404040;
}

.suggestion-item.selected {
  background: #4CAF50;
  color: #ffffff;
}

.suggestion-item:last-child {
  border-bottom: none;
}

/* Improved terminal input area */
.terminal-input-area {
  position: relative;
}

/* Better cursor visibility */
.cursor {
  color: #ffffff;
  animation: blink 1s infinite;
  font-weight: bold;
  background: #4CAF50;
  padding: 0 1px;
}

/* Selection styling */
.command-input::selection {
  background: #4CAF50;
  color: #ffffff;
}

.command-input::-moz-selection {
  background: #4CAF50;
  color: #ffffff;
}

/* Terminal scrollbar improvements */
.terminal-body::-webkit-scrollbar {
  width: 12px;
}

.terminal-body::-webkit-scrollbar-track {
  background: #2d2d2d;
  border-radius: 6px;
}

.terminal-body::-webkit-scrollbar-thumb {
  background: #404040;
  border-radius: 6px;
  border: 2px solid #2d2d2d;
}

.terminal-body::-webkit-scrollbar-thumb:hover {
  background: #555555;
}

/* Responsive improvements */
@media (max-width: 768px) {
  .command-suggestions {
    max-height: 150px;
  }
  
  .suggestion-item {
    padding: 6px 8px;
    font-size: 12px;
  }
}

/* Loading states */
.terminal-loading {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 100px;
  color: #4CAF50;
}

.terminal-loading .spinner {
  width: 20px;
  height: 20px;
  border: 2px solid #404040;
  border-top: 2px solid #4CAF50;
  border-radius: 50%;
  animation: spin 1s linear infinite;
  margin-right: 10px;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* Error states */
.terminal-error {
  background: #ff6b6b;
  color: #ffffff;
  padding: 10px;
  margin: 10px 0;
  border-radius: 4px;
  font-weight: bold;
}

/* Success states */
.terminal-success {
  background: #4CAF50;
  color: #ffffff;
  padding: 10px;
  margin: 10px 0;
  border-radius: 4px;
  font-weight: bold;
}
</style>

<script src="https://cdn.socket.io/4.7.4/socket.io.min.js"></script>

<script>
// ==========================
// Đợi Socket.IO load xong
// ==========================
function waitForSocketIO() {
  return new Promise((resolve, reject) => {
    if (typeof io !== 'undefined') {
      resolve();
    } else {
      // Kiểm tra mỗi 100ms với timeout 10 giây
      let attempts = 0;
      const maxAttempts = 100; // 10 giây
      
      const checkInterval = setInterval(() => {
        attempts++;
        if (typeof io !== 'undefined') {
          clearInterval(checkInterval);
          resolve();
        } else if (attempts >= maxAttempts) {
          clearInterval(checkInterval);
          reject(new Error('Socket.IO failed to load after 10 seconds'));
        }
      }, 100);
    }
  });
}

// ==========================
// Quản lý target liên kết
// ==========================
function render_target_info() {
  $.ajax({
    url: `/api/getalltarget`,
    type: 'GET',
    success: function(resp) {
      // Xóa các option cũ, chỉ giữ lại option đầu tiên
      $('#targetSelect').find('option:not(:first)').remove();
      // Thêm các target mới vào select
      $.each(resp.targets, function(index, item) {
        $('#targetSelect').append(
          $('<option>', {
            value: item.server_id,
            text: `${item.hostname} (${item.ip_address})`
          })
        );
      });
    },
    error: function(error) {
      console.error('Lỗi khi lấy danh sách target:', error);
    }
  });
}

// ==========================
// Terminal thật với Socket.IO
// ==========================
let isConnected = false; // Trạng thái kết nối shell
let currentShellId = '{{ shell.connection_id }}';
let currentShellData = null;
let commandHistory = [];
let historyIndex = -1;
let shellReady = false; // Trạng thái shell đã sẵn sàng
let outputBuffer = ''; // Buffer để xử lý output bị chia nhỏ

// Terminal state management
let cursorPosition = 0; // Vị trí con trỏ
let currentCommand = ''; // Lệnh hiện tại
let isTyping = false; // Đang gõ
let selectionStart = 0; // Vị trí bắt đầu selection
let selectionEnd = 0; // Vị trí kết thúc selection

// Khởi tạo terminal
function initTerminal() {
  $('#terminalContent').html(`
    <div class="terminal-line">
      
      <span class="command" id="currentCommand"></span>
      <span class="cursor" id="cursor">|</span>
    </div>
  `);
  commandHistory = [];
  historyIndex = -1;
}

// Loại bỏ ANSI escape sequences
function removeAnsi(str) {
  return str
    // Xử lý tất cả ANSI escape sequences
    .replace(/\x1B\[[0-?]*[ -/]*[@-~]/g, '') // ANSI color codes cơ bản
    .replace(/\x1B\]8;[^;]*;[^;]*\x07/g, '') // OSC sequences (file links)
    .replace(/\x1B\[[0-9]*[ABCDEFGJKST]/g, '') // Cursor movement
    .replace(/\x1B\[[0-9]*[hl]/g, '') // Mode changes
    .replace(/\x1B\[[0-9]*[JK]/g, '') // Erase operations
    .replace(/\x1B\[[0-9]*[m]/g, '') // Color attributes
    .replace(/\x1B\[[0-9]*[r]/g, '') // Scroll region
    .replace(/\x1B\[[0-9]*[d]/g, '') // Line positioning
    .replace(/\x1B\[[0-9]*[G]/g, '') // Cursor positioning
    .replace(/\x1B\[[0-9]*[H]/g, '') // Cursor positioning
    .replace(/\x1B\[[0-9]*[f]/g, '') // Cursor positioning
    .replace(/\x1B\[[0-9]*[s]/g, '') // Save cursor
    .replace(/\x1B\[[0-9]*[u]/g, '') // Restore cursor
    .replace(/\x1B\[[0-9]*[n]/g, '') // Device status
    .replace(/\x1B\[[0-9]*[c]/g, '') // Device attributes
    .replace(/\x1B\[[0-9]*[y]/g, '') // Device attributes
    .replace(/\x1B\[[0-9]*[q]/g, '') // Device attributes
    .replace(/\x1B\[[0-9]*[p]/g, '') // Device attributes
    .replace(/\x1B\[[0-9]*[g]/g, '') // Tab stops
    .replace(/\x1B\[[0-9]*[i]/g, '') // Print
    .replace(/\x1B\[[0-9]*[Z]/g, '') // Tab backward
    .replace(/\x1B\[[0-9]*[@]/g, '') // Insert characters
    .replace(/\x1B\[[0-9]*[P]/g, '') // Delete characters
    .replace(/\x1B\[[0-9]*[X]/g, '') // Erase characters
    .replace(/\x1B\[[0-9]*[L]/g, '') // Insert lines
    .replace(/\x1B\[[0-9]*[M]/g, '') // Delete lines
    .replace(/\x1B\[[0-9]*[T]/g, '') // Scroll down
    .replace(/\x1B\[[0-9]*[S]/g, '') // Scroll up
    .replace(/\x1B\[[0-9]*[b]/g, '') // Repeat character
    .replace(/\x1B\[[0-9]*[a]/g, '') // Cursor up
    .replace(/\x1B\[[0-9]*[e]/g, '') // Cursor down
    .replace(/\x1B\[[0-9]*[C]/g, '') // Cursor forward
    .replace(/\x1B\[[0-9]*[D]/g, '') // Cursor backward
    // Xử lý các escape sequences phức tạp hơn
    .replace(/\x1B\[[0-9;]*[ABCDEFGJKST]/g, '') // Cursor movement với parameters
    .replace(/\x1B\[[0-9;]*[hl]/g, '') // Mode changes với parameters
    .replace(/\x1B\[[0-9;]*[JK]/g, '') // Erase operations với parameters
    .replace(/\x1B\[[0-9;]*[m]/g, '') // Color attributes với parameters
    .replace(/\x1B\[[0-9;]*[r]/g, '') // Scroll region với parameters
    .replace(/\x1B\[[0-9;]*[d]/g, '') // Line positioning với parameters
    .replace(/\x1B\[[0-9;]*[G]/g, '') // Cursor positioning với parameters
    .replace(/\x1B\[[0-9;]*[H]/g, '') // Cursor positioning với parameters
    .replace(/\x1B\[[0-9;]*[f]/g, '') // Cursor positioning với parameters
    .replace(/\x1B\[[0-9;]*[s]/g, '') // Save cursor với parameters
    .replace(/\x1B\[[0-9;]*[u]/g, '') // Restore cursor với parameters
    .replace(/\x1B\[[0-9;]*[n]/g, '') // Device status với parameters
    .replace(/\x1B\[[0-9;]*[c]/g, '') // Device attributes với parameters
    .replace(/\x1B\[[0-9;]*[y]/g, '') // Device attributes với parameters
    .replace(/\x1B\[[0-9;]*[q]/g, '') // Device attributes với parameters
    .replace(/\x1B\[[0-9;]*[p]/g, '') // Device attributes với parameters
    .replace(/\x1B\[[0-9;]*[g]/g, '') // Tab stops với parameters
    .replace(/\x1B\[[0-9;]*[i]/g, '') // Print với parameters
    .replace(/\x1B\[[0-9;]*[Z]/g, '') // Tab backward với parameters
    .replace(/\x1B\[[0-9;]*[@]/g, '') // Insert characters với parameters
    .replace(/\x1B\[[0-9;]*[P]/g, '') // Delete characters với parameters
    .replace(/\x1B\[[0-9;]*[X]/g, '') // Erase characters với parameters
    .replace(/\x1B\[[0-9;]*[L]/g, '') // Insert lines với parameters
    .replace(/\x1B\[[0-9;]*[M]/g, '') // Delete lines với parameters
    .replace(/\x1B\[[0-9;]*[T]/g, '') // Scroll down với parameters
    .replace(/\x1B\[[0-9;]*[S]/g, '') // Scroll up với parameters
    .replace(/\x1B\[[0-9;]*[b]/g, '') // Repeat character với parameters
    .replace(/\x1B\[[0-9;]*[a]/g, '') // Cursor up với parameters
    .replace(/\x1B\[[0-9;]*[e]/g, '') // Cursor down với parameters
    .replace(/\x1B\[[0-9;]*[C]/g, '') // Cursor forward với parameters
    .replace(/\x1B\[[0-9;]*[D]/g, '') // Cursor backward với parameters
    // Xử lý các escape sequences đặc biệt
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[hl]/g, '') // Private mode changes
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[JK]/g, '') // Private erase operations
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[m]/g, '') // Private color attributes
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[r]/g, '') // Private scroll region
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[d]/g, '') // Private line positioning
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[G]/g, '') // Private cursor positioning
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[H]/g, '') // Private cursor positioning
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[f]/g, '') // Private cursor positioning
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[s]/g, '') // Private save cursor
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[u]/g, '') // Private restore cursor
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[n]/g, '') // Private device status
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[c]/g, '') // Private device attributes
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[y]/g, '') // Private device attributes
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[q]/g, '') // Private device attributes
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[p]/g, '') // Private device attributes
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[g]/g, '') // Private tab stops
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[i]/g, '') // Private print
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[Z]/g, '') // Private tab backward
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[@]/g, '') // Private insert characters
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[P]/g, '') // Private delete characters
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[X]/g, '') // Private erase characters
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[L]/g, '') // Private insert lines
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[M]/g, '') // Private delete lines
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[T]/g, '') // Private scroll down
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[S]/g, '') // Private scroll up
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[b]/g, '') // Private repeat character
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[a]/g, '') // Private cursor up
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[e]/g, '') // Private cursor down
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[C]/g, '') // Private cursor forward
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[D]/g, '') // Private cursor backward
    // Xử lý các escape sequences khác
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[hl]/g, '') // Secondary mode changes
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[JK]/g, '') // Secondary erase operations
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[m]/g, '') // Secondary color attributes
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[r]/g, '') // Secondary scroll region
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[d]/g, '') // Secondary line positioning
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[G]/g, '') // Secondary cursor positioning
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[H]/g, '') // Secondary cursor positioning
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[f]/g, '') // Secondary cursor positioning
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[s]/g, '') // Secondary save cursor
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[u]/g, '') // Secondary restore cursor
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[n]/g, '') // Secondary device status
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[c]/g, '') // Secondary device attributes
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[y]/g, '') // Secondary device attributes
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[q]/g, '') // Secondary device attributes
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[p]/g, '') // Secondary device attributes
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[g]/g, '') // Secondary tab stops
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[i]/g, '') // Secondary print
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[Z]/g, '') // Secondary tab backward
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[@]/g, '') // Secondary insert characters
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[P]/g, '') // Secondary delete characters
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[X]/g, '') // Secondary erase characters
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[L]/g, '') // Secondary insert lines
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[M]/g, '') // Secondary delete lines
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[T]/g, '') // Secondary scroll down
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[S]/g, '') // Secondary scroll up
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[b]/g, '') // Secondary repeat character
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[a]/g, '') // Secondary cursor up
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[e]/g, '') // Secondary cursor down
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[C]/g, '') // Secondary cursor forward
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[D]/g, '') // Secondary cursor backward
    // Xử lý các escape sequences cuối cùng
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[hl]/g, '') // Tertiary mode changes
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[JK]/g, '') // Tertiary erase operations
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[m]/g, '') // Tertiary color attributes
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[r]/g, '') // Tertiary scroll region
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[d]/g, '') // Tertiary line positioning
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[G]/g, '') // Tertiary cursor positioning
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[H]/g, '') // Tertiary cursor positioning
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[f]/g, '') // Tertiary cursor positioning
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[s]/g, '') // Tertiary save cursor
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[u]/g, '') // Tertiary restore cursor
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[n]/g, '') // Tertiary device status
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[c]/g, '') // Tertiary device attributes
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[y]/g, '') // Tertiary device attributes
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[q]/g, '') // Tertiary device attributes
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[p]/g, '') // Tertiary device attributes
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[g]/g, '') // Tertiary tab stops
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[i]/g, '') // Tertiary print
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[Z]/g, '') // Tertiary tab backward
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[@]/g, '') // Tertiary insert characters
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[P]/g, '') // Tertiary delete characters
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[X]/g, '') // Tertiary erase characters
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[L]/g, '') // Tertiary insert lines
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[M]/g, '') // Tertiary delete lines
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[T]/g, '') // Tertiary scroll down
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[S]/g, '') // Tertiary scroll up
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[b]/g, '') // Tertiary repeat character
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[a]/g, '') // Tertiary cursor up
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[e]/g, '') // Tertiary cursor down
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[C]/g, '') // Tertiary cursor forward
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[D]/g, '') // Tertiary cursor backward
    // Xử lý các escape sequences đặc biệt khác
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[hl]/g, '') // Special mode changes
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[JK]/g, '') // Special erase operations
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[m]/g, '') // Special color attributes
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[r]/g, '') // Special scroll region
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[d]/g, '') // Special line positioning
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[G]/g, '') // Special cursor positioning
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[H]/g, '') // Special cursor positioning
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[f]/g, '') // Special cursor positioning
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[s]/g, '') // Special save cursor
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[u]/g, '') // Special restore cursor
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[n]/g, '') // Special device status
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[c]/g, '') // Special device attributes
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[y]/g, '') // Special device attributes
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[q]/g, '') // Special device attributes
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[p]/g, '') // Special device attributes
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[g]/g, '') // Special tab stops
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[i]/g, '') // Special print
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[Z]/g, '') // Special tab backward
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[@]/g, '') // Special insert characters
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[P]/g, '') // Special delete characters
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[X]/g, '') // Special erase characters
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[L]/g, '') // Special insert lines
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[M]/g, '') // Special delete lines
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[T]/g, '') // Special scroll down
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[S]/g, '') // Special scroll up
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[b]/g, '') // Special repeat character
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[a]/g, '') // Special cursor up
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[e]/g, '') // Special cursor down
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[C]/g, '') // Special cursor forward
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[D]/g, '') // Special cursor backward
    // Xử lý các escape sequences cuối cùng
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[hl]/g, '') // Complex mode changes
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[JK]/g, '') // Complex erase operations
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[m]/g, '') // Complex color attributes
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[r]/g, '') // Complex scroll region
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[d]/g, '') // Complex line positioning
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[G]/g, '') // Complex cursor positioning
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[H]/g, '') // Complex cursor positioning
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[f]/g, '') // Complex cursor positioning
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[s]/g, '') // Complex save cursor
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[u]/g, '') // Complex restore cursor
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[n]/g, '') // Complex device status
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[c]/g, '') // Complex device attributes
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[y]/g, '') // Complex device attributes
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[q]/g, '') // Complex device attributes
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[p]/g, '') // Complex device attributes
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[g]/g, '') // Complex tab stops
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[i]/g, '') // Complex print
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[Z]/g, '') // Complex tab backward
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[@]/g, '') // Complex insert characters
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[P]/g, '') // Complex delete characters
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[X]/g, '') // Complex erase characters
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[L]/g, '') // Complex insert lines
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[M]/g, '') // Complex delete lines
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[T]/g, '') // Complex scroll down
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[S]/g, '') // Complex scroll up
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[b]/g, '') // Complex repeat character
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[a]/g, '') // Complex cursor up
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[e]/g, '') // Complex cursor down
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[C]/g, '') // Complex cursor forward
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[D]/g, ''); // Complex cursor backward
}

// In output ra terminal
function printOutput(output, type = 'normal') {
  const terminalContent = $('#terminalContent');
  
  // Loại bỏ ANSI escape sequences để hiển thị text sạch
  const cleanOutput = removeAnsi(output);
  
  // Sử dụng pre để giữ nguyên format và whitespace
  const outputDiv = $('<div>', {
    class: `output-line ${type === 'error' ? 'error-line' : type === 'success' ? 'success-line' : ''}`
  }).html(`<pre style="margin: 0; font-family: inherit; white-space: pre-wrap;">${cleanOutput}</pre>`);
  
  terminalContent.append(outputDiv);
  
  // Scroll xuống cuối
  const terminalBody = $('#terminalOutput');
  terminalBody.scrollTop(terminalBody[0].scrollHeight);
}

// In prompt mới
function printPrompt() {
  const terminalContent = $('#terminalContent');
  
  // Kiểm tra xem đã có prompt ở cuối chưa
  const lastChild = terminalContent.children().last();
  if (lastChild.length && lastChild.hasClass('terminal-line')) {
    // Đã có prompt, không cần tạo mới
    return;
  }
  
  const promptDiv = $('<div>', {
    class: 'terminal-line'
  }).html(`
    <span class="command" id="currentCommand"></span>
    <span class="cursor" id="cursor">|</span>
  `);
  terminalContent.append(promptDiv);
  
  // Scroll xuống cuối
  const terminalBody = $('#terminalOutput');
  terminalBody.scrollTop(terminalBody[0].scrollHeight);
  
  // Focus vào input
  focusInput();
}

// Focus vào input terminal
function focusInput() {
  const input = $('#commandInput');
  input.focus();
  
  // Đặt con trỏ ở cuối
  const range = document.createRange();
  const selection = window.getSelection();
  range.selectNodeContents(input[0]);
  range.collapse(false);
  selection.removeAllRanges();
  selection.addRange(range);
  
  cursorPosition = currentCommand.length;
  updateCursor();
}

// Cập nhật vị trí con trỏ
function updateCursor() {
  const input = $('#commandInput');
  const text = input.text();
  
  // Tạo range để đặt con trỏ
  const range = document.createRange();
  const selection = window.getSelection();
  
  if (cursorPosition <= text.length) {
    let node = input[0].firstChild;
    if (!node) {
      node = document.createTextNode('');
      input[0].appendChild(node);
    }
    
    range.setStart(node, Math.min(cursorPosition, text.length));
    range.setEnd(node, Math.min(cursorPosition, text.length));
    
    selection.removeAllRanges();
    selection.addRange(range);
  }
}

// Xử lý phím tắt
function handleKeyDown(e) {
  const key = e.key;
  const ctrl = e.ctrlKey;
  const shift = e.shiftKey;
  const alt = e.altKey;
  
  console.log('[DEBUG] Key pressed:', key, 'Ctrl:', ctrl, 'Shift:', shift, 'Alt:', alt);
  
  // Enter - Gửi lệnh
  if (key === 'Enter') {
    e.preventDefault();
    const command = $('#commandInput').text().trim();
    if (command) {
      sendCommandToShell(command);
      $('#commandInput').text('');
      currentCommand = '';
      cursorPosition = 0;
    }
    return;
  }
  
  // Tab - Auto-completion hoặc indent
  if (key === 'Tab') {
    e.preventDefault();
    if (shift) {
      // Shift+Tab - Unindent
      insertText('    ');
    } else {
      // Tab - Indent hoặc auto-completion
      insertText('    ');
    }
    return;
  }
  
  // Arrow keys
  if (key === 'ArrowLeft') {
    e.preventDefault();
    if (ctrl) {
      // Ctrl+Left - Word left
      moveCursorWordLeft();
    } else {
      // Left - Character left
      cursorPosition = Math.max(0, cursorPosition - 1);
      updateCursor();
    }
    return;
  }
  
  if (key === 'ArrowRight') {
    e.preventDefault();
    if (ctrl) {
      // Ctrl+Right - Word right
      moveCursorWordRight();
    } else {
      // Right - Character right
      cursorPosition = Math.min(currentCommand.length, cursorPosition + 1);
      updateCursor();
    }
    return;
  }
  
  if (key === 'ArrowUp') {
    e.preventDefault();
    if (ctrl) {
      // Ctrl+Up - Scroll up
      scrollTerminalUp();
    } else {
      // Up - History up
      navigateHistoryUp();
    }
    return;
  }
  
  if (key === 'ArrowDown') {
    e.preventDefault();
    if (ctrl) {
      // Ctrl+Down - Scroll down
      scrollTerminalDown();
    } else {
      // Down - History down
      navigateHistoryDown();
    }
    return;
  }
  
  // Home/End
  if (key === 'Home') {
    e.preventDefault();
    if (ctrl) {
      // Ctrl+Home - Start of terminal
      scrollTerminalToTop();
    } else {
      // Home - Start of line
      cursorPosition = 0;
      updateCursor();
    }
    return;
  }
  
  if (key === 'End') {
    e.preventDefault();
    if (ctrl) {
      // Ctrl+End - End of terminal
      scrollTerminalToBottom();
    } else {
      // End - End of line
      cursorPosition = currentCommand.length;
      updateCursor();
    }
    return;
  }
  
  // Ctrl+A - Select all
  if (ctrl && key === 'a') {
    e.preventDefault();
    selectAll();
    return;
  }
  
  // Ctrl+C - Copy
  if (ctrl && key === 'c') {
    e.preventDefault();
    copySelection();
    return;
  }
  
  // Ctrl+V - Paste
  if (ctrl && key === 'v') {
    e.preventDefault();
    pasteFromClipboard();
    return;
  }
  
  // Ctrl+X - Cut
  if (ctrl && key === 'x') {
    e.preventDefault();
    cutSelection();
    return;
  }
  
  // Ctrl+L - Clear screen
  if (ctrl && key === 'l') {
    e.preventDefault();
    clearTerminal();
    return;
  }
  
  // Ctrl+U - Clear line before cursor
  if (ctrl && key === 'u') {
    e.preventDefault();
    clearLineBeforeCursor();
    return;
  }
  
  // Ctrl+K - Clear line after cursor
  if (ctrl && key === 'k') {
    e.preventDefault();
    clearLineAfterCursor();
    return;
  }
  
  // Ctrl+W - Delete word before cursor
  if (ctrl && key === 'w') {
    e.preventDefault();
    deleteWordBeforeCursor();
    return;
  }
  
  // Backspace
  if (key === 'Backspace') {
    e.preventDefault();
    if (cursorPosition > 0) {
      currentCommand = currentCommand.slice(0, cursorPosition - 1) + currentCommand.slice(cursorPosition);
      cursorPosition--;
      $('#commandInput').text(currentCommand);
      updateCursor();
    }
    return;
  }
  
  // Delete
  if (key === 'Delete') {
    e.preventDefault();
    if (cursorPosition < currentCommand.length) {
      currentCommand = currentCommand.slice(0, cursorPosition) + currentCommand.slice(cursorPosition + 1);
      $('#commandInput').text(currentCommand);
      updateCursor();
    }
    return;
  }
  
  // Escape - Clear current line
  if (key === 'Escape') {
    e.preventDefault();
    currentCommand = '';
    cursorPosition = 0;
    $('#commandInput').text('');
    updateCursor();
    return;
  }
}

// Các hàm hỗ trợ
function insertText(text) {
  currentCommand = currentCommand.slice(0, cursorPosition) + text + currentCommand.slice(cursorPosition);
  cursorPosition += text.length;
  $('#commandInput').text(currentCommand);
  updateCursor();
}

function moveCursorWordLeft() {
  const words = currentCommand.split(/\s+/);
  let pos = 0;
  for (let i = 0; i < words.length; i++) {
    if (pos + words[i].length >= cursorPosition) {
      cursorPosition = pos;
      break;
    }
    pos += words[i].length + 1;
  }
  updateCursor();
}

function moveCursorWordRight() {
  const words = currentCommand.split(/\s+/);
  let pos = 0;
  for (let i = 0; i < words.length; i++) {
    pos += words[i].length + 1;
    if (pos > cursorPosition) {
      cursorPosition = pos - 1;
      break;
    }
  }
  updateCursor();
}

function navigateHistoryUp() {
  if (historyIndex > 0) {
    historyIndex--;
    currentCommand = commandHistory[historyIndex];
    cursorPosition = currentCommand.length;
    $('#commandInput').text(currentCommand);
    updateCursor();
  }
}

function navigateHistoryDown() {
  if (historyIndex < commandHistory.length - 1) {
    historyIndex++;
    currentCommand = commandHistory[historyIndex];
    cursorPosition = currentCommand.length;
    $('#commandInput').text(currentCommand);
    updateCursor();
  } else if (historyIndex === commandHistory.length - 1) {
    historyIndex++;
    currentCommand = '';
    cursorPosition = 0;
    $('#commandInput').text('');
    updateCursor();
  }
}

function scrollTerminalUp() {
  const terminalBody = $('#terminalOutput');
  terminalBody.scrollTop(terminalBody.scrollTop() - 50);
}

function scrollTerminalDown() {
  const terminalBody = $('#terminalOutput');
  terminalBody.scrollTop(terminalBody.scrollTop() + 50);
}

function scrollTerminalToTop() {
  const terminalBody = $('#terminalOutput');
  terminalBody.scrollTop(0);
}

function scrollTerminalToBottom() {
  const terminalBody = $('#terminalOutput');
  terminalBody.scrollTop(terminalBody[0].scrollHeight);
}

function selectAll() {
  const input = $('#commandInput');
  const range = document.createRange();
  const selection = window.getSelection();
  range.selectNodeContents(input[0]);
  selection.removeAllRanges();
  selection.addRange(range);
}

function copySelection() {
  const selection = window.getSelection();
  if (selection.toString()) {
    navigator.clipboard.writeText(selection.toString());
  }
}

function pasteFromClipboard() {
  navigator.clipboard.readText().then(text => {
    insertText(text);
  });
}

function cutSelection() {
  const selection = window.getSelection();
  if (selection.toString()) {
    navigator.clipboard.writeText(selection.toString());
    // Xóa selection
    const range = selection.getRangeAt(0);
    range.deleteContents();
  }
}

function clearTerminal() {
  $('#terminalContent').empty();
  if (isConnected) {
    printPrompt();
  } else {
    printOutput('Đang chờ kết nối reverse shell...');
  }
}

function clearLineBeforeCursor() {
  currentCommand = currentCommand.slice(cursorPosition);
  cursorPosition = 0;
  $('#commandInput').text(currentCommand);
  updateCursor();
}

function clearLineAfterCursor() {
  currentCommand = currentCommand.slice(cursorPosition);
  $('#commandInput').text(currentCommand);
  updateCursor();
}

function deleteWordBeforeCursor() {
  const beforeCursor = currentCommand.slice(0, cursorPosition);
  const afterCursor = currentCommand.slice(cursorPosition);
  const words = beforeCursor.split(/\s+/);
  if (words.length > 1) {
    words.pop();
    const newBefore = words.join(' ');
    currentCommand = newBefore + afterCursor;
    cursorPosition = newBefore.length;
    $('#commandInput').text(currentCommand);
    updateCursor();
  }
}

// ==========================
// Tích hợp Socket.IO cho realtime shell
// ==========================
let socket = null;

// Khởi tạo Socket.IO khi đã sẵn sàng
async function initializeSocketIO() {
  console.log('[DEBUG] Waiting for Socket.IO to load...');
  try {
    await waitForSocketIO();
    console.log('[DEBUG] Socket.IO loaded, initializing connection...');
    
    socket = io.connect('http://' + document.domain + ':' + location.port);
    console.log('[DEBUG] Socket connection created');

// Khi kết nối socket thành công
socket.on('connect', function() {
      console.log('[DEBUG] Socket connected successfully');
  printOutput('Đã kết nối tới server Socket.IO', 'success');
  // Tham gia room shell hiện tại
  socket.emit('join_shell', { shell_id: currentShellId });
      
      // Kiểm tra xem shell đã connected chưa
      if (isConnected && shellReady) {
        console.log('[DEBUG] Socket connected and shell is ready, initializing terminal');
        initializeTerminalForConnectedShell();
      }
    });
    
    // Khi socket disconnect
    socket.on('disconnect', function() {
      console.log('[DEBUG] Socket disconnected');
      printOutput('Mất kết nối tới server Socket.IO', 'error');
    });
    
    // Khi socket error
    socket.on('connect_error', function(error) {
      console.error('[DEBUG] Socket connection error:', error);
      printOutput('Lỗi kết nối Socket.IO: ' + error, 'error');
});

// Nhận cập nhật trạng thái shell từ server (realtime)
socket.on('shell_status_update', function(data) {
  console.log('[DEBUG] Received shell_status_update:', data);
  if (data.shell_id !== currentShellId) return;
  updateToggleShellBtn(data.status);
  $('#shellStatus').removeClass('bg-success bg-warning bg-secondary bg-danger');
  if (data.status === 'CLOSED') {
    $('#shellStatus').addClass('bg-secondary').text('Closed');
    isConnected = false;
    shellReady = false;
    outputBuffer = '';
    initTerminal();
    printOutput('Shell đã đóng. Nhấn "Bật Shell" để kết nối lại.');
  } else if (data.status === 'LISTENING') {
    $('#shellStatus').addClass('bg-warning').text('Listening');
    isConnected = false;
    shellReady = false;
    outputBuffer = '';
    initTerminal();
    printOutput('Đang chờ kết nối reverse shell...');
  } else if (data.status === 'CONNECTED') {
    console.log('[DEBUG] Shell connected, setting isConnected = true');
    $('#shellStatus').addClass('bg-success').text('Connected');
    isConnected = true;
        
        // Kiểm tra xem terminal đã được khởi tạo chưa
    if (!$('#terminalContent').children().length) {
      // Chỉ init terminal nếu chưa có nội dung
      initTerminal();
      printOutput('Shell đã kết nối thành công!', 'success');
    }
        
    // Không in prompt ngay, đợi output từ pwncat
    // Focus vào input khi kết nối thành công
    $('#commandInput').focus();
    
    // Enable input khi shell đã kết nối
    $('#commandInput').prop('disabled', false);
    $('#sendCommand').prop('disabled', false);
        $('#disconnectShell').prop('disabled', false);
    
    // Auto-set shellReady sau 3 giây nếu chưa được set
    setTimeout(() => {
      if (!shellReady && isConnected) {
        console.log('[DEBUG] Auto-setting shellReady after timeout');
        shellReady = true;
      }
    }, 3000);
  } else if (data.status === 'ERROR') {
    $('#shellStatus').addClass('bg-danger').text('Error');
    isConnected = false;
    shellReady = false;
    outputBuffer = '';
    printOutput(`Lỗi: ${data.error || 'Unknown error'}`, 'error');
  }
  // Enable/disable disconnect button theo trạng thái
  $('#disconnectShell').prop('disabled', !isConnected);
  $('#commandInput').prop('disabled', !isConnected);
  $('#sendCommand').prop('disabled', !isConnected);
});

// Nhận output từ shell (realtime) - PTY mode
socket.on('terminal_output', function(data) {
  console.log('[DEBUG] Received terminal_output:', data);
      if (data.shell_id !== currentShellId) {
        console.log('[DEBUG] Ignoring output for different shell:', data.shell_id);
        return;
      }
  if (data.output) {
    console.log('[DEBUG] Writing to terminal:', JSON.stringify(data.output));
    
    // Thêm output vào buffer
    outputBuffer += data.output;
    
    // Kiểm tra xem buffer có chứa warning không
    const cleanBuffer = removeAnsi(outputBuffer);
    if (cleanBuffer.includes('WARNING: your terminal doesn\'t support cursor position requests (CPR).')) {
      // Bỏ qua warning này, không hiển thị
          console.log('[DEBUG] Skipping CPR warning');
      outputBuffer = '';
      return;
    }
    
    // Kiểm tra xem buffer có chứa prompt không (pwncat prompt)
    if (cleanBuffer.includes('pwncat$') || cleanBuffer.includes('(local) pwncat$')) {
      // Đã nhận prompt từ pwncat, shell đã sẵn sàng
      shellReady = true;
      console.log('[DEBUG] Shell ready detected from prompt');
      
      // In buffer và reset
      if (outputBuffer.trim()) {
        printOutput(outputBuffer);
      }
      outputBuffer = '';
      
      // Chỉ in prompt nếu chưa có prompt ở cuối
      const terminalContent = $('#terminalContent');
      const lastChild = terminalContent.children().last();
      if (!lastChild.length || !lastChild.hasClass('terminal-line')) {
        setTimeout(() => printPrompt(), 100);
      }
          
          // Enable input nếu chưa được enable
          if ($('#commandInput').prop('disabled')) {
            console.log('[DEBUG] Enabling input after prompt detection');
            $('#commandInput').prop('disabled', false);
            $('#disconnectShell').prop('disabled', false);
            focusInput();
          }
          
        } else if (cleanBuffer.includes('registered new host') && !shellReady) {
      // Đã nhận thông báo host được đăng ký, shell gần như sẵn sàng
      console.log('[DEBUG] Host registered detected, shell almost ready');
      // Không set shellReady ngay, đợi prompt
    } else {
      // Kiểm tra xem có phải là output hoàn chỉnh không (có newline)
      if (outputBuffer.includes('\n') || outputBuffer.includes('\r')) {
        // In buffer và reset
        if (outputBuffer.trim()) {
          printOutput(outputBuffer);
        }
        outputBuffer = '';
      }
    }
  }
});
    
    // Nhận thông báo đã tham gia shell room
    socket.on('joined_shell', function(data) {
      console.log('[DEBUG] Joined shell room:', data);
      if (data.shell_id === currentShellId) {
        console.log('[DEBUG] Successfully joined shell room for:', currentShellId);
        
        // Kiểm tra xem shell đã connected chưa
        if (isConnected && shellReady) {
          console.log('[DEBUG] Shell is already connected, initializing terminal');
          initializeTerminalForConnectedShell();
        }
      }
    });
    
    console.log('[DEBUG] Socket.IO initialization completed');
  } catch (error) {
    console.error('[DEBUG] Error initializing Socket.IO:', error);
    printOutput('Lỗi khởi tạo Socket.IO: ' + error.message, 'error');
    
    // Fallback: tạo socket đơn giản
    try {
      socket = io.connect('http://' + document.domain + ':' + location.port);
      console.log('[DEBUG] Fallback socket created');
    } catch (fallbackError) {
      console.error('[DEBUG] Fallback socket also failed:', fallbackError);
    }
  }
}

// ==========================
// Các hàm thao tác shell
// ==========================

// Gửi yêu cầu join shell (khi bật shell)
function connectToShell(shellId) {
  console.log('[DEBUG] connectToShell called for:', shellId);
  
  if (!socket) {
    console.log('[DEBUG] Socket not initialized, cannot connect to shell');
    return;
  }
  
  // Tham gia shell room
  socket.emit('join_shell', { shell_id: shellId });
  
  // Kiểm tra xem shell đã connected chưa
  if (isConnected && shellReady) {
    console.log('[DEBUG] Shell already connected and ready, no need to start');
    return;
  }
  
  // Gửi request bật shell qua socket (chỉ khi chưa connected)
  socket.emit('shell_start', { shell_id: shellId });
}

// Hàm kiểm tra và khởi tạo terminal cho shell đã connected
function initializeTerminalForConnectedShell() {
  console.log('[DEBUG] Initializing terminal for connected shell');
  console.log('[DEBUG] Current state - isConnected:', isConnected, 'shellReady:', shellReady);
  
  // Khởi tạo terminal nếu chưa có
  if (!$('#terminalContent').children().length) {
    console.log('[DEBUG] Terminal content is empty, initializing...');
    initTerminal();
  } else {
    console.log('[DEBUG] Terminal content already exists');
  }
  
  // Enable input
  console.log('[DEBUG] Enabling input elements...');
  $('#commandInput').prop('disabled', false);
  $('#disconnectShell').prop('disabled', false);
  
  // Focus vào input
  console.log('[DEBUG] Setting focus to input...');
  setTimeout(() => {
    focusInput();
    console.log('[DEBUG] Focus set to input');
  }, 100);
  
  // In thông báo sẵn sàng
  printOutput('Shell đã sẵn sàng. Bạn có thể bắt đầu nhập lệnh!', 'success');
  
  // Set shellReady
  shellReady = true;
  isConnected = true;
  
  console.log('[DEBUG] Terminal initialized for connected shell - isConnected:', isConnected, 'shellReady:', shellReady);
}

// Gửi lệnh tới shell qua socket (PTY mode)
function sendCommandToShell(command) {
  console.log('[DEBUG] sendCommandToShell called with:', command);
  console.log('[DEBUG] Current state - isConnected:', isConnected, 'shellReady:', shellReady);
  
  if (!socket) {
    console.log('[DEBUG] Socket not initialized, cannot send command');
    printOutput('Socket chưa kết nối!', 'error');
    return;
  }
  
  if (!currentShellId || !isConnected) {
    console.log('[DEBUG] Shell not connected, cannot send command');
    printOutput('Shell chưa kết nối!', 'error');
    return;
  }
  
  // Kiểm tra shellReady, nhưng nếu đã connected thì vẫn cho phép gửi lệnh
  if (!shellReady && isConnected) {
    console.log('[DEBUG] Shell connected but not ready, attempting to send command anyway');
  }
  
  // Thêm lệnh vào history
  if (command.trim()) {
    commandHistory.push(command);
    historyIndex = commandHistory.length;
  }
  
  // In lệnh ra terminal
  const terminalContent = $('#terminalContent');
  const lastLine = terminalContent.children().last();
  if (lastLine.length && lastLine.hasClass('terminal-line')) {
    lastLine.find('.command').text(command);
  }
  
  console.log('[DEBUG] Sending command via socket:', command);
  // Gửi lệnh + newline để thực thi
  socket.emit('terminal_input', {
    shell_id: currentShellId,
    input: command + '\n'
  });
  
  // Reset input
  currentCommand = '';
  cursorPosition = 0;
  $('#commandInput').text('');
  
  console.log('[DEBUG] Command sent successfully');
  // Không in prompt ngay, đợi output từ shell
}

// Ngắt kết nối shell
function disconnectShell() {
  if (!socket) {
    console.log('[DEBUG] Socket not initialized, cannot disconnect shell');
    return;
  }
  
  if (currentShellId) {
    // Gửi signal đóng shell hoàn toàn
    socket.emit('shell_stop', { 
      shell_id: currentShellId,
      action: 'close_completely'
    });
    
    // Gửi AJAX request để đóng shell
    $.ajax({
      url: `/api/shells/${currentShellId}/close`,
      type: 'POST',
      data: JSON.stringify({action: 'close_completely'}),
      contentType: 'application/json',
      success: function(resp) {
        console.log('[DEBUG] Shell closed successfully:', resp);
        printOutput('Shell đã đóng hoàn toàn.', 'info');
      },
      error: function(xhr) {
        console.error('[DEBUG] Error closing shell:', xhr);
        printOutput('Lỗi khi đóng shell.', 'error');
      }
    });
  }
  
  isConnected = false;
  shellReady = false;
  $('#shellStatus').removeClass('bg-success bg-warning').addClass('bg-secondary').text('Disconnected');
  $('#disconnectShell').prop('disabled', true);
  $('#commandInput').prop('disabled', true);
  $('#sendCommand').prop('disabled', true);
  printOutput('Shell đã đóng hoàn toàn.');
}

// ==========================
// Xử lý input từ terminal thật
// ==========================
$('#commandInput').on('keydown', handleKeyDown);

// Xử lý input text
$('#commandInput').on('input', function() {
  console.log('[DEBUG] Input event triggered');
  currentCommand = $(this).text();
  cursorPosition = currentCommand.length;
});

// Xử lý click để focus
$('#commandInput').on('click', function() {
  console.log('[DEBUG] Input clicked, focusing...');
  focusInput();
  // Kiểm tra và khôi phục terminal state nếu cần
  checkAndRestoreTerminalState();
});

// Xử lý paste
$('#commandInput').on('paste', function(e) {
  e.preventDefault();
  const text = (e.originalEvent || e).clipboardData.getData('text/plain');
  insertText(text);
});

// Xử lý copy
$('#commandInput').on('copy', function(e) {
  const selection = window.getSelection();
  if (selection.toString()) {
    e.originalEvent.clipboardData.setData('text/plain', selection.toString());
  }
});

// Xử lý cut
$('#commandInput').on('cut', function(e) {
  const selection = window.getSelection();
  if (selection.toString()) {
    e.originalEvent.clipboardData.setData('text/plain', selection.toString());
    // Xóa selection
    const range = selection.getRangeAt(0);
    range.deleteContents();
  }
});

// ==========================
// Xử lý các nút chức năng UI
// ==========================
$('#clearTerminal').click(function() {
  clearTerminal();
});

// Thêm các phím tắt toàn cục
$(document).on('keydown', function(e) {
  // Ctrl+L - Clear terminal
  if (e.ctrlKey && e.key === 'l') {
    e.preventDefault();
    clearTerminal();
  }
  
  // Ctrl+Shift+C - Copy từ terminal
  if (e.ctrlKey && e.shiftKey && e.key === 'C') {
    e.preventDefault();
    const selection = window.getSelection();
    if (selection.toString()) {
      navigator.clipboard.writeText(selection.toString());
    }
  }
  
  // Ctrl+Shift+V - Paste vào terminal
  if (e.ctrlKey && e.shiftKey && e.key === 'V') {
    e.preventDefault();
    navigator.clipboard.readText().then(text => {
      insertText(text);
    });
  }
  
  // Focus vào terminal khi nhấn Ctrl+`
  if (e.ctrlKey && e.key === '`') {
    e.preventDefault();
    focusInput();
  }
});

$('#fullscreen').click(function() {
  $('.shell-container').toggleClass('fullscreen');
});

$('#disconnectShell').click(function() {
  if (confirm('Bạn có chắc muốn ngắt kết nối shell này?')) {
    disconnectShell();
  }
});

$('#toggleShellBtn').click(function() {
  $.ajax({
    url: `/api/shells/${currentShellId}`,
    type: 'GET',
    success: function(resp) {
      if (resp.status === 'success') {
        const status = resp.data.status.toUpperCase();
        if (status === 'CLOSED' || status === 'DISCONNECTED' || status === 'ERROR') {
          // Bật shell
          console.log('[DEBUG] Starting shell:', currentShellId);
          connectToShell(currentShellId);
          
          // Cập nhật UI ngay lập tức
          $('#shellStatus').removeClass('bg-secondary bg-danger').addClass('bg-warning').text('Starting...');
          updateToggleShellBtn('LISTENING');
          
          // Thông báo cho user
          printOutput('Đang khởi động shell...', 'info');
        } else {
          // Tắt shell
          if (confirm('Bạn có chắc muốn tắt shell này?')) {
            console.log('[DEBUG] Stopping shell:', currentShellId);
            disconnectShell();
            
            // Cập nhật UI ngay lập tức
            $('#shellStatus').removeClass('bg-success bg-warning').addClass('bg-secondary').text('Stopping...');
            updateToggleShellBtn('CLOSED');
            
            // Thông báo cho user
            printOutput('Đang tắt shell...', 'info');
          }
        }
      }
    },
    error: function(xhr) {
      printOutput(`Lỗi kiểm tra trạng thái: ${xhr.responseJSON?.msg || 'Unknown error'}`, 'error');
    }
  });
});

// Cập nhật giao diện nút bật/tắt shell theo trạng thái
function updateToggleShellBtn(status) {
  status = status.toUpperCase();
  if (status === 'CLOSED' || status === 'DISCONNECTED' || status === 'ERROR') {
    $('#toggleShellBtnText').text('Bật Shell');
    $('#toggleShellBtn').removeClass('btn-outline-danger').addClass('btn-outline-success');
  } else {
    $('#toggleShellBtnText').text('Tắt Shell');
    $('#toggleShellBtn').removeClass('btn-outline-success').addClass('btn-outline-danger');
  }
}

// Kiểm tra trạng thái shell khi load trang
function refreshShellStatus() {
  console.log('[DEBUG] Refreshing shell status for:', currentShellId);
  
  $.ajax({
    url: `/api/shells/${currentShellId}`,
    type: 'GET',
    success: function(resp) {
      if (resp.status === 'success') {
        const status = resp.data.status.toUpperCase();
        console.log('[DEBUG] Current shell status:', status);
        
        // Cập nhật UI theo trạng thái
        updateToggleShellBtn(status);
        
        if (status === 'CONNECTED') {
          console.log('[DEBUG] Shell is connected, initializing terminal for existing connection');
          $('#shellStatus').removeClass('bg-secondary bg-warning').addClass('bg-success').text('Connected');
          
          // Khởi tạo terminal cho shell đã connected
          initializeTerminalForConnectedShell();
          
          // Tham gia shell room và kết nối
          connectToShell(currentShellId);
          
        } else if (status === 'LISTENING') {
          console.log('[DEBUG] Shell is listening');
          $('#shellStatus').removeClass('bg-success bg-secondary').addClass('bg-warning').text('Listening');
          isConnected = false;
          shellReady = false;
          
          // Tham gia shell room để nhận updates
          socket.emit('join_shell', { shell_id: currentShellId });
          
          // Disable input
          $('#commandInput').prop('disabled', true);
          $('#disconnectShell').prop('disabled', true);
          
          initTerminal();
          printOutput('Đang chờ kết nối reverse shell...', 'info');
          
        } else if (status === 'CLOSED' || status === 'DISCONNECTED' || status === 'ERROR') {
          console.log('[DEBUG] Shell is closed/disconnected');
          $('#shellStatus').removeClass('bg-success bg-warning').addClass('bg-secondary').text(status);
          isConnected = false;
          shellReady = false;
          
          // Disable input
          $('#commandInput').prop('disabled', true);
          $('#disconnectShell').prop('disabled', true);
          
          initTerminal();
          printOutput('Shell đã đóng. Nhấn "Bật Shell" để kết nối lại.', 'info');
          
        } else {
          console.log('[DEBUG] Unknown shell status:', status);
          $('#shellStatus').removeClass('bg-success bg-warning').addClass('bg-secondary').text(status);
          isConnected = false;
          shellReady = false;
          
          // Disable input
          $('#commandInput').prop('disabled', true);
          $('#disconnectShell').prop('disabled', true);
          
          initTerminal();
          printOutput(`Trạng thái shell: ${status}`, 'info');
        }
        
        // Tham gia shell room để nhận updates realtime (nếu chưa join)
        if (socket) {
          socket.emit('join_shell', { shell_id: currentShellId });
        } else {
          console.log('[DEBUG] Socket not initialized, cannot join shell room');
        }
        
      } else {
        console.error('[DEBUG] Failed to get shell status:', resp);
        printOutput(`Lỗi lấy trạng thái shell: ${resp.msg || 'Unknown error'}`, 'error');
        
        // Fallback: tham gia shell room để nhận updates
        socket.emit('join_shell', { shell_id: currentShellId });
      }
    },
    error: function(xhr) {
      console.error('[DEBUG] Error refreshing shell status:', xhr);
      printOutput(`Lỗi kiểm tra trạng thái: ${xhr.responseJSON?.msg || 'Unknown error'}`, 'error');
      
      // Fallback: tham gia shell room để nhận updates
      if (socket) {
        socket.emit('join_shell', { shell_id: currentShellId });
      } else {
        console.log('[DEBUG] Socket not initialized, cannot join shell room');
      }
    }
  });
}

// ==========================
// Khởi tạo khi load trang
// ==========================
$(document).ready(async function() {
  console.log('[DEBUG] Initializing view-shell page for shell:', currentShellId);
  
  // Reset terminal state khi vào lại
  resetTerminalState();
  
  // Khởi tạo Socket.IO trước
  await initializeSocketIO();
  
  initTerminal(); // Khởi tạo terminal
  render_target_info(); // Lấy danh sách target
  refreshShellStatus(); // Kiểm tra trạng thái shell ban đầu
  
  // Focus vào terminal khi load
  setTimeout(() => {
    focusInput();
    // Debug terminal state sau 2 giây
    setTimeout(() => {
      debugTerminalState();
    }, 2000);
  }, 500);
  
  // Thêm tooltip cho phím tắt
  $('[data-toggle="tooltip"]').tooltip();
  
  // Thêm context menu cho terminal
  $('#terminalOutput').on('contextmenu', function(e) {
    e.preventDefault();
    // Có thể thêm context menu ở đây
  });
  
  // Auto-resize terminal khi window resize
  $(window).on('resize', function() {
    const terminalBody = $('#terminalOutput');
    const containerHeight = $('.shell-container').height();
    const headerHeight = $('.terminal-header').outerHeight();
    const inputHeight = $('.terminal-input-area').outerHeight();
    const buttonHeight = $('.p-2').outerHeight();
    
    const newHeight = containerHeight - headerHeight - inputHeight - buttonHeight - 30;
    terminalBody.css('max-height', newHeight + 'px');
  });
  
  // Trigger resize event
  $(window).trigger('resize');
  
  // ==========================
  // RESET TERMINAL STATE
  // ==========================
  function resetTerminalState() {
    console.log('[DEBUG] Resetting terminal state');
    
    // Reset các biến global
    isConnected = false;
    shellReady = false;
    outputBuffer = '';
    commandHistory = [];
    historyIndex = -1;
    cursorPosition = 0;
    currentCommand = '';
    selectionStart = 0;
    selectionEnd = 0;
    
    // Reset UI elements
    $('#commandInput').prop('disabled', true);
    $('#disconnectShell').prop('disabled', true);
    $('#shellStatus').removeClass('bg-success bg-warning bg-danger').addClass('bg-secondary').text('Initializing...');
    
    // Clear terminal content
    $('#terminalContent').empty();
    
    // Reset suggestions
    hideSuggestions();
    
    console.log('[DEBUG] Terminal state reset completed');
  }
});

// ==========================
// AUTO-COMPLETION SYSTEM
// ==========================
let commandSuggestions = [];
let currentSuggestionIndex = -1;
let isShowingSuggestions = false;

// Danh sách lệnh phổ biến
const commonCommands = [
    'ls', 'cd', 'pwd', 'cat', 'grep', 'find', 'ps', 'top', 'kill', 'chmod', 'chown',
    'cp', 'mv', 'rm', 'mkdir', 'rmdir', 'touch', 'nano', 'vim', 'vi', 'less', 'more',
    'head', 'tail', 'wc', 'sort', 'uniq', 'cut', 'awk', 'sed', 'tr', 'tee',
    'ssh', 'scp', 'rsync', 'wget', 'curl', 'ping', 'netstat', 'ifconfig', 'ip',
    'systemctl', 'service', 'apt', 'yum', 'pip', 'python', 'node', 'npm',
    'docker', 'kubectl', 'git', 'tar', 'zip', 'unzip', 'gzip', 'bzip2',
    'whoami', 'id', 'groups', 'passwd', 'sudo', 'su', 'exit', 'logout',
    'history', 'alias', 'export', 'source', 'echo', 'printf', 'read',
    'for', 'while', 'if', 'case', 'function', 'return', 'break', 'continue'
];

// Tạo suggestions dựa trên input
function generateSuggestions(input) {
    if (!input.trim()) return [];
    
    const suggestions = [];
    const inputLower = input.toLowerCase();
    
    // Tìm commands phù hợp
    for (const cmd of commonCommands) {
        if (cmd.toLowerCase().startsWith(inputLower)) {
            suggestions.push(cmd);
        }
    }
    
    // Thêm các suggestions đặc biệt
    if (inputLower.startsWith('ls')) {
        suggestions.push('ls -la', 'ls -lh', 'ls -R', 'ls -t');
    } else if (inputLower.startsWith('ps')) {
        suggestions.push('ps aux', 'ps -ef', 'ps -eo pid,ppid,cmd');
    } else if (inputLower.startsWith('find')) {
        suggestions.push('find . -name "*.txt"', 'find . -type f', 'find . -mtime -7');
    } else if (inputLower.startsWith('grep')) {
        suggestions.push('grep -r "pattern"', 'grep -i "pattern"', 'grep -v "pattern"');
    }
    
    return suggestions.slice(0, 10); // Giới hạn 10 suggestions
}

// Hiển thị suggestions
function showSuggestions(suggestions) {
    if (suggestions.length === 0) {
        hideSuggestions();
        return;
    }
    
    // Tạo dropdown suggestions
    let dropdown = $('#commandSuggestions');
    if (dropdown.length === 0) {
        dropdown = $('<div id="commandSuggestions" class="command-suggestions"></div>');
        $('.terminal-input-area').append(dropdown);
    }
    
    dropdown.empty();
    suggestions.forEach((suggestion, index) => {
        const item = $(`<div class="suggestion-item" data-index="${index}">${suggestion}</div>`);
        dropdown.append(item);
    });
    
    dropdown.show();
    isShowingSuggestions = true;
    currentSuggestionIndex = -1;
}

// Ẩn suggestions
function hideSuggestions() {
    $('#commandSuggestions').hide();
    isShowingSuggestions = false;
    currentSuggestionIndex = -1;
}

// Chọn suggestion
function selectSuggestion(index) {
    const suggestions = $('.suggestion-item');
    if (index >= 0 && index < suggestions.length) {
        suggestions.removeClass('selected');
        suggestions.eq(index).addClass('selected');
        currentSuggestionIndex = index;
    }
}

// Áp dụng suggestion
function applySuggestion() {
    if (currentSuggestionIndex >= 0) {
        const suggestion = $('.suggestion-item').eq(currentSuggestionIndex).text();
        currentCommand = suggestion;
        cursorPosition = suggestion.length;
        $('#commandInput').text(suggestion);
        updateCursor();
        hideSuggestions();
    }
}

// Xử lý Tab cho auto-completion
function handleTabCompletion() {
    const input = $('#commandInput').text();
    const suggestions = generateSuggestions(input);
    
    if (suggestions.length === 1) {
        // Nếu chỉ có 1 suggestion, áp dụng luôn
        currentCommand = suggestions[0];
        cursorPosition = suggestions[0].length;
        $('#commandInput').text(suggestions[0]);
        updateCursor();
        hideSuggestions();
    } else if (suggestions.length > 1) {
        // Nếu có nhiều suggestions, hiển thị dropdown
        showSuggestions(suggestions);
        selectSuggestion(0);
    }
}

// Cập nhật handleKeyDown để hỗ trợ auto-completion
const originalHandleKeyDown = window.handleKeyDown;
window.handleKeyDown = function(e) {
    const key = e.key;
    const ctrl = e.ctrlKey;
    const shift = e.shiftKey;
    const alt = e.altKey;
    
    // Tab - Auto-completion
    if (key === 'Tab') {
        e.preventDefault();
        if (isShowingSuggestions) {
            // Nếu đang hiển thị suggestions, chọn suggestion tiếp theo
            const suggestions = $('.suggestion-item');
            const nextIndex = (currentSuggestionIndex + 1) % suggestions.length;
            selectSuggestion(nextIndex);
        } else {
            // Tạo suggestions mới
            handleTabCompletion();
        }
        return;
    }
    
    // Enter - Áp dụng suggestion hoặc gửi lệnh
    if (key === 'Enter') {
        if (isShowingSuggestions) {
            e.preventDefault();
            applySuggestion();
            return;
        }
    }
    
    // Escape - Ẩn suggestions
    if (key === 'Escape') {
        if (isShowingSuggestions) {
            e.preventDefault();
            hideSuggestions();
            return;
        }
    }
    
    // Arrow keys trong suggestions
    if (isShowingSuggestions && (key === 'ArrowUp' || key === 'ArrowDown')) {
        e.preventDefault();
        const suggestions = $('.suggestion-item');
        let newIndex = currentSuggestionIndex;
        
        if (key === 'ArrowUp') {
            newIndex = currentSuggestionIndex <= 0 ? suggestions.length - 1 : currentSuggestionIndex - 1;
        } else {
            newIndex = currentSuggestionIndex >= suggestions.length - 1 ? 0 : currentSuggestionIndex + 1;
        }
        
        selectSuggestion(newIndex);
        return;
    }
    
    // Gọi hàm gốc
    originalHandleKeyDown.call(this, e);
    
    // Ẩn suggestions khi gõ
    if (isShowingSuggestions && key.length === 1) {
        hideSuggestions();
    }
};

// Click vào suggestion
$(document).on('click', '.suggestion-item', function() {
    const index = parseInt($(this).data('index'));
    selectSuggestion(index);
    applySuggestion();
});

// ==========================
// IMPROVED CURSOR HANDLING
// ==========================
function improvedUpdateCursor() {
    const input = $('#commandInput');
    const text = input.text();
    
    // Tạo range để đặt con trỏ chính xác hơn
    const range = document.createRange();
    const selection = window.getSelection();
    
    if (cursorPosition <= text.length) {
        let node = input[0].firstChild;
        if (!node) {
            node = document.createTextNode('');
            input[0].appendChild(node);
        }
        
        // Tính toán vị trí chính xác hơn
        let currentPos = 0;
        let targetNode = node;
        let targetOffset = 0;
        
        // Duyệt qua các node con để tìm vị trí chính xác
        const walker = document.createTreeWalker(
            input[0],
            NodeFilter.SHOW_TEXT,
            null,
            false
        );
        
        while (walker.nextNode()) {
            const textNode = walker.currentNode;
            const textLength = textNode.textContent.length;
            
            if (currentPos + textLength >= cursorPosition) {
                targetNode = textNode;
                targetOffset = cursorPosition - currentPos;
                break;
            }
            currentPos += textLength;
        }
        
        range.setStart(targetNode, targetOffset);
        range.setEnd(targetNode, targetOffset);
        
        selection.removeAllRanges();
        selection.addRange(range);
    }
}

// Override updateCursor function
window.updateCursor = improvedUpdateCursor;
  
  // Trigger resize event
  $(window).trigger('resize');
  
  // ==========================
  // XỬ LÝ BROWSER TAB CLOSE
  // ==========================
  let isPageUnloading = false;
  
  // Xử lý khi user đóng tab hoặc rời khỏi trang
  window.addEventListener('beforeunload', function(e) {
    if (isConnected && !isPageUnloading) {
      isPageUnloading = true;
      
      // Hiển thị cảnh báo cho user nhưng KHÔNG đóng shell
      const message = 'Shell đang kết nối. Shell sẽ tiếp tục chạy trong background. Bạn có thể mở lại tab này để tiếp tục sử dụng.';
      e.preventDefault();
      e.returnValue = message;
      
      // KHÔNG gửi signal đóng shell - để shell tiếp tục chạy
      console.log('[DEBUG] Tab closing, but shell will continue running in background');
      
      return message;
    }
  });
  
  // Xử lý khi page visibility thay đổi (tab ẩn/hiện)
  document.addEventListener('visibilitychange', function() {
    if (document.hidden && isConnected) {
      console.log('[DEBUG] Page hidden, shell still running in background');
      // Có thể thêm logic để pause shell hoặc hiển thị thông báo
    } else if (!document.hidden && isConnected) {
      console.log('[DEBUG] Page visible, checking terminal state');
      // Kiểm tra và khôi phục terminal state khi tab được focus lại
      setTimeout(() => {
        checkAndRestoreTerminalState();
      }, 500);
    }
  });
  
  // ==========================
  // CẢI THIỆN TRẢI NGHIỆM TERMINAL
  // ==========================
  
  // Cải thiện cursor positioning
  function improvedUpdateCursor() {
    const input = $('#commandInput');
    const text = input.text();
    
    // Tạo range để đặt con trỏ chính xác hơn
    const range = document.createRange();
    const selection = window.getSelection();
    
    if (cursorPosition <= text.length) {
      let node = input[0].firstChild;
      if (!node) {
        node = document.createTextNode('');
        input[0].appendChild(node);
      }
      
      // Tính toán vị trí chính xác hơn
      let currentPos = 0;
      let targetNode = node;
      let targetOffset = 0;
      
      // Duyệt qua các node con để tìm vị trí chính xác
      const walker = document.createTreeWalker(
        input[0],
        NodeFilter.SHOW_TEXT,
        null,
        false
      );
      
      while (walker.nextNode()) {
        const textNode = walker.currentNode;
        const textLength = textNode.textContent.length;
        
        if (currentPos + textLength >= cursorPosition) {
          targetNode = textNode;
          targetOffset = cursorPosition - currentPos;
          break;
        }
        currentPos += textLength;
      }
      
      range.setStart(targetNode, targetOffset);
      range.setEnd(targetNode, targetOffset);
      
      selection.removeAllRanges();
      selection.addRange(range);
    }
  }
  
  // Cải thiện selection handling
  function handleSelectionChange() {
    const selection = window.getSelection();
    if (selection.rangeCount > 0) {
      const range = selection.getRangeAt(0);
      const input = $('#commandInput')[0];
      
      if (input.contains(range.startContainer)) {
        // Tính toán vị trí selection trong input
        const startOffset = getTextOffset(input, range.startContainer, range.startOffset);
        const endOffset = getTextOffset(input, range.endContainer, range.endOffset);
        
        selectionStart = startOffset;
        selectionEnd = endOffset;
      }
    }
  }
  
  function getTextOffset(root, node, offset) {
    let totalOffset = 0;
    const walker = document.createTreeWalker(
      root,
      NodeFilter.SHOW_TEXT,
      null,
      false
    );
    
    while (walker.nextNode()) {
      const textNode = walker.currentNode;
      if (textNode === node) {
        return totalOffset + offset;
      }
      totalOffset += textNode.textContent.length;
    }
    return totalOffset;
  }
  
  // Cải thiện copy/paste
  function improvedPaste(e) {
    e.preventDefault();
    const text = (e.originalEvent || e).clipboardData.getData('text/plain');
    
    // Xử lý paste với selection
    if (selectionStart !== selectionEnd) {
      // Xóa selection trước
      const beforeSelection = currentCommand.slice(0, selectionStart);
      const afterSelection = currentCommand.slice(selectionEnd);
      currentCommand = beforeSelection + text + afterSelection;
      cursorPosition = selectionStart + text.length;
    } else {
      // Paste tại vị trí con trỏ
      currentCommand = currentCommand.slice(0, cursorPosition) + text + currentCommand.slice(cursorPosition);
      cursorPosition += text.length;
    }
    
    $('#commandInput').text(currentCommand);
    improvedUpdateCursor();
    
    // Reset selection
    selectionStart = selectionEnd = cursorPosition;
  }
  
  // Cải thiện copy
  function improvedCopy(e) {
    const selection = window.getSelection();
    if (selection.toString()) {
      e.originalEvent.clipboardData.setData('text/plain', selection.toString());
    } else {
      // Copy toàn bộ text nếu không có selection
      e.originalEvent.clipboardData.setData('text/plain', currentCommand);
    }
  }
  
  // Cải thiện cut
  function improvedCut(e) {
    const selection = window.getSelection();
    if (selection.toString()) {
      e.originalEvent.clipboardData.setData('text/plain', selection.toString());
      
      // Xóa selection
      const beforeSelection = currentCommand.slice(0, selectionStart);
      const afterSelection = currentCommand.slice(selectionEnd);
      currentCommand = beforeSelection + afterSelection;
      cursorPosition = selectionStart;
      
      $('#commandInput').text(currentCommand);
      improvedUpdateCursor();
      
      // Reset selection
      selectionStart = selectionEnd = cursorPosition;
    }
  }
  
  // Thêm event listeners cho cải thiện
  $('#commandInput').on('selectionchange', handleSelectionChange);
  $('#commandInput').off('paste').on('paste', improvedPaste);
  $('#commandInput').off('copy').on('copy', improvedCopy);
  $('#commandInput').off('cut').on('cut', improvedCut);
  
  // ==========================
  // PERFORMANCE OPTIMIZATION
  // ==========================
  
  // Debounce resize events
  let resizeTimeout;
  $(window).off('resize').on('resize', function() {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(function() {
      const terminalBody = $('#terminalOutput');
      const containerHeight = $('.shell-container').height();
      const headerHeight = $('.terminal-header').outerHeight();
      const inputHeight = $('.terminal-input-area').outerHeight();
      const buttonHeight = $('.p-2').outerHeight();
      
      const newHeight = containerHeight - headerHeight - inputHeight - buttonHeight - 30;
      terminalBody.css('max-height', newHeight + 'px');
    }, 100);
  });
  
  // Limit terminal output để tránh memory leak
  const MAX_TERMINAL_LINES = 1000;
  function limitTerminalOutput() {
    const terminalContent = $('#terminalContent');
    const lines = terminalContent.children();
    
    if (lines.length > MAX_TERMINAL_LINES) {
      // Xóa các dòng cũ nhất
      const linesToRemove = lines.length - MAX_TERMINAL_LINES;
      lines.slice(0, linesToRemove).remove();
    }
  }
  
  // Override printOutput để limit output
  const originalPrintOutput = window.printOutput;
  window.printOutput = function(output, type = 'normal') {
    originalPrintOutput(output, type);
    limitTerminalOutput();
  };
  
  // ==========================
  // SESSION MANAGEMENT
  // ==========================
  
  // Auto-save session state
  function saveSessionState() {
    const state = {
      commandHistory: commandHistory,
      currentCommand: currentCommand,
      cursorPosition: cursorPosition,
      isConnected: isConnected,
      shellReady: shellReady
    };
    localStorage.setItem('terminal_session_' + currentShellId, JSON.stringify(state));
  }
  
  function loadSessionState() {
    const saved = localStorage.getItem('terminal_session_' + currentShellId);
    if (saved) {
      try {
        const state = JSON.parse(saved);
        commandHistory = state.commandHistory || [];
        currentCommand = state.currentCommand || '';
        cursorPosition = state.cursorPosition || 0;
        // Không restore isConnected và shellReady vì cần kiểm tra lại
      } catch (e) {
        console.error('Error loading session state:', e);
      }
    }
  }
  
  // Auto-save mỗi 30 giây
  setInterval(saveSessionState, 30000);
  
  // Load session state khi khởi tạo
  loadSessionState();
  
  // Cleanup khi rời khỏi trang
  window.addEventListener('pagehide', function() {
    saveSessionState();
  });
  
  // ==========================
  // RESET TERMINAL STATE
  // ==========================
  function resetTerminalState() {
    console.log('[DEBUG] Resetting terminal state');
    
    // Reset các biến global
    isConnected = false;
    shellReady = false;
    outputBuffer = '';
    commandHistory = [];
    historyIndex = -1;
    cursorPosition = 0;
    currentCommand = '';
    selectionStart = 0;
    selectionEnd = 0;
    
    // Reset UI elements
    $('#commandInput').prop('disabled', true);
    $('#disconnectShell').prop('disabled', true);
    $('#shellStatus').removeClass('bg-success bg-warning bg-danger').addClass('bg-secondary').text('Initializing...');
    
    // Clear terminal content
    $('#terminalContent').empty();
    
    // Reset suggestions
    hideSuggestions();
    
    console.log('[DEBUG] Terminal state reset completed');
  }
  
  // Nhận thông báo đã tham gia shell room
  socket.on('joined_shell', function(data) {
    console.log('[DEBUG] Joined shell room:', data);
    if (data.shell_id === currentShellId) {
      console.log('[DEBUG] Successfully joined shell room for:', currentShellId);
      
      // Kiểm tra xem shell đã connected chưa
      if (isConnected && shellReady) {
        console.log('[DEBUG] Shell is already connected, initializing terminal');
        initializeTerminalForConnectedShell();
      }
    }
  });

  // Hàm kiểm tra và khôi phục terminal state
  function checkAndRestoreTerminalState() {
    console.log('[DEBUG] Checking terminal state...');
    
    // Kiểm tra xem shell có đang connected không
    if (isConnected && shellReady) {
      console.log('[DEBUG] Shell is connected and ready, checking terminal state');
      
      // Kiểm tra xem input có bị disabled không
      if ($('#commandInput').prop('disabled')) {
        console.log('[DEBUG] Input is disabled, enabling...');
        $('#commandInput').prop('disabled', false);
        $('#disconnectShell').prop('disabled', false);
      }
      
      // Kiểm tra xem terminal có nội dung không
      if (!$('#terminalContent').children().length) {
        console.log('[DEBUG] Terminal is empty, initializing...');
        initializeTerminalForConnectedShell();
      }
      
      // Focus vào input
      setTimeout(() => {
        focusInput();
      }, 100);
    }
  }
  
  // Test function để debug terminal state
  function debugTerminalState() {
    console.log('[DEBUG] === TERMINAL STATE DEBUG ===');
    console.log('[DEBUG] isConnected:', isConnected);
    console.log('[DEBUG] shellReady:', shellReady);
    console.log('[DEBUG] currentShellId:', currentShellId);
    console.log('[DEBUG] input disabled:', $('#commandInput').prop('disabled'));
    console.log('[DEBUG] disconnect disabled:', $('#disconnectShell').prop('disabled'));
    console.log('[DEBUG] terminal content children:', $('#terminalContent').children().length);
    console.log('[DEBUG] shell status text:', $('#shellStatus').text());
    console.log('[DEBUG] === END DEBUG ===');
  }
  
  // Expose debug function globally
  window.debugTerminalState = debugTerminalState;
  
  // Force sync shell status function
  function forceSyncShellStatus() {
    console.log('[DEBUG] Force syncing shell status for:', currentShellId);
    
    $.ajax({
      url: `/api/shells/${currentShellId}/force-sync`,
      type: 'POST',
      success: function(resp) {
        if (resp.status === 'success') {
          console.log('[DEBUG] Force sync successful:', resp);
          printOutput(`Shell status synced: ${resp.memory_status} -> ${resp.database_status}`, 'success');
          
          // Refresh shell status sau khi sync
          setTimeout(() => {
            refreshShellStatus();
          }, 1000);
        } else {
          console.error('[DEBUG] Force sync failed:', resp);
          printOutput(`Force sync failed: ${resp.msg}`, 'error');
        }
      },
      error: function(xhr) {
        console.error('[DEBUG] Force sync error:', xhr);
        printOutput(`Force sync error: ${xhr.responseJSON?.msg || 'Unknown error'}`, 'error');
      }
    });
  }
  
  // Expose force sync function globally
  window.forceSyncShellStatus = forceSyncShellStatus;

  // Function để đóng shell hoàn toàn
  function closeShellCompletely() {
    if (confirm('Bạn có chắc muốn đóng shell hoàn toàn?')) {
      disconnectShell();
      printOutput('Shell đã đóng hoàn toàn.', 'info');
    }
  }
</script>
{% endblock content %}