{% extends "layouts/base.html" %}

{% block content %}
<div class="container-fluid py-4">
  <div class="row">
    <div class="col-12">
      <!-- Header th√¥ng tin shell -->
      <div class="card mb-4">
        <div class="card-header pb-0 d-flex flex-wrap justify-content-between align-items-center">
          <div>
            <h5 class="mb-1">Shell Detail</h5>
            <div class="d-flex flex-wrap gap-3 align-items-center">
              <span class="badge bg-dark">Session: {{ shell.connection_id }}</span>
              <span class="badge bg-info">Type: {{ shell.shell_type.name }}</span>
              <span class="badge bg-secondary">Status: {{ shell.status.name }}</span>
              <span class="badge bg-success">User: {{ shell.user or 'N/A' }}</span>
              <span class="badge bg-warning text-dark">Privilege: {{ shell.privilege_level or 'N/A' }}</span>
            </div>
          </div>
          <div class="text-end">
            <div class="mb-1">
              <i class="fas fa-calendar-alt me-1"></i> Created: {{ shell.created_at|replace('T', ' ')|truncate(19, True, '') if shell.created_at }}
            </div>
            <div>
              <i class="fas fa-clock me-1"></i> Updated: {{ shell.updated_at|replace('T', ' ')|truncate(19, True, '') if shell.updated_at }}
            </div>
          </div>
        </div>
        <div class="card-body py-2">
          <div class="row g-3">
            <div class="col-md-4">
              <div class="border rounded p-3 h-100">
                <h6 class="mb-2"><i class="fas fa-network-wired me-1"></i> Listen (Local)</h6>
                <div><strong>IP:</strong> {{ shell.local_ip or 'N/A' }}</div>
                <div><strong>Port:</strong> {{ shell.local_port or 'N/A' }}</div>
              </div>
            </div>
            <div class="col-md-4">
              <div class="border rounded p-3 h-100">
                <h6 class="mb-2"><i class="fas fa-globe me-1"></i> Remote</h6>
                <div><strong>IP:</strong> {{ shell.remote_ip or 'N/A' }}</div>
                <div><strong>Port:</strong> {{ shell.remote_port or 'N/A' }}</div>
              </div>
            </div>
            <div class="col-md-4">
              <div class="border rounded p-3 h-100">
                <h6 class="mb-2"><i class="fas fa-bullseye me-1"></i> Linked Target</h6>
                <div id="linkedTargetInfo">
                  {% if shell.target_id and shell.target_id|int > 0 %}
                    <div><strong>Hostname:</strong> <span id="linkedTargetHostname">{{ shell.hostname or 'N/A' }}</span></div>
                    <div><strong>Target ID:</strong> <a href="/targets/{{ shell.target_id }}" target="_blank" id="linkedTargetId">{{ shell.target_id }}</a></div>
                  {% else %}
                    <div class="text-muted">No target linked</div>
                  {% endif %}
                </div>
                <!-- Khu v·ª±c c·∫≠p nh·∫≠t li√™n k·∫øt target -->
                <div class="mt-2">
                  <select id="targetSelect" class="form-select form-select-sm mb-1">
                    <option value="">-- Ch·ªçn target ƒë·ªÉ li√™n k·∫øt --</option>
                    {% for t in targets %}
                      <option value="{{ t.server_id }}" {% if shell.target_id==t.server_id %}selected{% endif %}>{{ t.hostname }} ({{ t.ip_address }})</option>
                    {% endfor %}
                  </select>
                  <button class="btn btn-sm btn-outline-primary" id="updateTargetBtn">C·∫≠p nh·∫≠t li√™n k·∫øt</button>
                  <span id="updateTargetStatus" class="ms-2 text-success" style="display:none;"></span>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <!-- Ghi ch√∫ cho shell -->
      <div class="card mb-4">
        <div class="card-header pb-0 d-flex align-items-center justify-content-between">
          <h6 class="mb-0"><i class="fas fa-sticky-note me-2"></i>Shell Notes</h6>
          <button class="btn btn-sm btn-outline-primary" id="saveNoteBtn"><i class="fas fa-save me-1"></i>Save Note</button>
        </div>
        <div class="card-body">
          <textarea id="shellNote" class="form-control" rows="3" >{{ shell.notes or '' }}</textarea>
          <div id="noteStatus" class="mt-2 text-success" style="display:none;"></div>
        </div>
      </div>
      <!-- Terminal t∆∞∆°ng t√°c tr·ª±c ti·∫øp -->
      <div class="card mb-4">
        <div class="card-header pb-0 d-flex align-items-center justify-content-between">
          <h6 class="mb-0"><i class="fas fa-terminal me-2"></i>Interactive Shell</h6>
          <span id="shellStatus" class="badge bg-secondary ms-2">Disconnected</span>
        </div>
        <div class="card-body p-0">
          <div class="shell-container">
            <div class="terminal-header">
              <div class="terminal-controls">
                <span class="control close"></span>
                <span class="control minimize"></span>
                <span class="control maximize"></span>
              </div>
              <div class="terminal-title">
                <i class="fas fa-server me-2"></i>
                <span id="targetInfo">Target: {{ shell.hostname or shell_name or shell_id }}</span>
              </div>
            </div>
            <!-- Terminal output area -->
            <div class="terminal-body" id="terminalOutput">
              <div class="terminal-content" id="terminalContent">
                <div class="terminal-line">
                  
                  <span class="command" id="currentCommand"></span>
                </div>
              </div>
            </div>
            <!-- Terminal input area -->
            <div class="terminal-input-area" id="terminalInputArea">
              <div class="terminal-line" id="currentInputLine">
                <span class="prompt" id="currentPrompt"></span>
                <span class="command-input" id="commandInput" contenteditable="true" spellcheck="false"></span>
                
              </div>
            </div>
            <div class="p-2 d-flex gap-2">
              <button type="button" class="btn btn-outline-secondary btn-sm" id="clearTerminal">
                <i class="fas fa-trash me-1"></i>Clear
              </button>
              <button type="button" class="btn btn-outline-secondary btn-sm" id="saveOutput">
                <i class="fas fa-save me-1"></i>Save
              </button>
              <button type="button" class="btn btn-outline-secondary btn-sm" id="fullscreen">
                <i class="fas fa-expand me-1"></i>Fullscreen
              </button>
              <button type="button" class="btn btn-outline-info btn-sm" id="loadHistory">
                <i class="fas fa-history me-1"></i>History
              </button>
              <!-- N√∫t debug terminal state -->
              <button type="button" class="btn btn-outline-secondary btn-sm" id="debugTerminal" onclick="debugTerminalState()">
                <i class="fas fa-bug me-1"></i>Debug
              </button>
              <!-- N√∫t force sync shell status -->
              <button type="button" class="btn btn-outline-info btn-sm" id="forceSyncBtn" onclick="forceSyncShellStatus()">
                <i class="fas fa-sync me-1"></i>Force Sync
              </button>
              <!-- N√∫t b·∫≠t/t·∫Øt shell -->
              <button type="button" class="btn btn-outline-warning btn-sm" id="toggleShellBtn">
                <i class="fas fa-power-off me-1"></i><span id="toggleShellBtnText">T·∫Øt Shell</span>
              </button>
              <!-- N√∫t ƒë√≥ng shell ho√†n to√†n -->
              <button type="button" class="btn btn-outline-danger btn-sm" id="closeShellBtn" onclick="closeShellCompletely()">
                <i class="fas fa-times-circle me-1"></i>Close Shell
              </button>
              <button type="button" class="btn btn-danger btn-sm ms-auto" id="disconnectShell" disabled>
                <i class="fas fa-times me-1"></i>Disconnect
              </button>
            </div>
          </div>
        </div>
      </div>
      
      <div class="mb-4">
        <button type="button" class="btn btn-outline-primary btn-sm" id="toggleFileManagerBtn">
          <i class="fas fa-folder-open me-1"></i><span id="toggleFileManagerBtnText">Hi·ªán Tr√¨nh qu·∫£n l√Ω File</span>
        </button>
      </div>
      
      <div id="fileManagerContainer" style="display:none;">
        {% include "weevely/partial-updown-file.html" %}
      </div>
    </div>
  </div>
</div>

<style>
.shell-container {
  background: #1e1e1e;
  border-radius: 8px;
  overflow: hidden;
  font-family: 'Courier New', monospace;
  height: 500px;
  display: flex;
  flex-direction: column;
}
.terminal-header {
  background: #2d2d2d;
  padding: 8px 15px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  border-bottom: 1px solid #404040;
}
.terminal-controls { display: flex; gap: 8px; }
.control { width: 12px; height: 12px; border-radius: 50%; cursor: pointer; }
.control.close { background: #ff5f56; }
.control.minimize { background: #ffbd2e; }
.control.maximize { background: #27ca3f; }
.terminal-title { color: #ffffff; font-size: 14px; font-weight: 500; }
.terminal-body { 
  flex: 1; 
  padding: 15px; 
  overflow-y: auto; 
  background: #1e1e1e; 
  color: #ffffff; 
  font-size: 14px; 
  line-height: 1.4; 
  max-height: 300px;
}
.terminal-content { min-height: 100%; }
.terminal-line { margin-bottom: 5px; display: flex; align-items: center; }
.prompt { color: #4CAF50; font-weight: bold; margin-right: 10px; white-space: nowrap; }
.command { color: #ffffff; flex: 1; }
.cursor { color: #ffffff; animation: blink 1s infinite; margin-left: 2px; }
@keyframes blink { 0%, 50% { opacity: 1; } 51%, 100% { opacity: 0; } }
.output-line { color: #cccccc; margin-bottom: 5px; word-wrap: break-word; }
.error-line { color: #ff6b6b; }
.success-line { color: #4CAF50; }
.terminal-input-area { 
  padding: 15px; 
  background: #1e1e1e; 
  border-top: 1px solid #404040; 
}
.terminal-input-area .terminal-line {
  display: flex;
  align-items: center;
  background: transparent;
  border: none;
  padding: 0;
  margin: 0;
}
.command-input {
  flex: 1;
  background: transparent;
  border: none;
  color: #ffffff;
  font-family: 'Courier New', monospace;
  font-size: 14px;
  outline: none;
  min-height: 20px;
  white-space: pre-wrap;
  word-wrap: break-word;
  overflow-wrap: break-word;
}
.command-input:focus {
  background: transparent;
  border: none;
  color: #ffffff;
  box-shadow: none;
}
.command-input[contenteditable="true"]:empty:before {
  content: '';
}
.terminal-body::-webkit-scrollbar { width: 8px; }
.terminal-body::-webkit-scrollbar-track { background: #2d2d2d; }
.terminal-body::-webkit-scrollbar-thumb { background: #404040; border-radius: 4px; }
.terminal-body::-webkit-scrollbar-thumb:hover { background: #555555; }
.terminal-line { animation: slideIn 0.3s ease; }
@keyframes slideIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
#shellStatus { animation: pulse 2s infinite; }
@keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.7; } 100% { opacity: 1; } }
.shell-container.fullscreen { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 9999; border-radius: 0; }

/* Terminal th·∫≠t styling */
.terminal-line {
  position: relative;
  min-height: 20px;
  line-height: 1.4;
}

.command-input {
  position: relative;
  display: inline-block;
  min-width: 1px;
}

.command-input:focus {
  outline: none;
}

/* Cursor animation */
.cursor {
  animation: blink 1s infinite;
  font-weight: bold;
}

@keyframes blink {
  0%, 50% { opacity: 1; }
  51%, 100% { opacity: 0; }
}

/* Selection styling */
.command-input::selection {
  background: #4CAF50;
  color: #ffffff;
}

.command-input::-moz-selection {
  background: #4CAF50;
  color: #ffffff;
}

/* Terminal font */
.terminal-body, .command-input {
  font-family: 'Courier New', 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
  font-size: 14px;
  line-height: 1.4;
}

/* Responsive terminal */
@media (max-width: 768px) {
  .terminal-body, .command-input {
    font-size: 12px;
  }
  
  .shell-container {
    height: 400px;
  }
}

/* Terminal colors */
.prompt { color: #4CAF50; font-weight: bold; }
.command { color: #ffffff; }
.output-line { color: #cccccc; }
.error-line { color: #ff6b6b; }
.success-line { color: #4CAF50; }
.warning-line { color: #ffa726; }
.info-line { color: #42a5f5; }

/* Auto-completion styles */
.command-suggestions {
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  background: #2d2d2d;
  border: 1px solid #404040;
  border-top: none;
  max-height: 200px;
  overflow-y: auto;
  z-index: 1000;
  display: none;
}

.suggestion-item {
  padding: 8px 12px;
  color: #ffffff;
  cursor: pointer;
  border-bottom: 1px solid #404040;
  font-family: 'Courier New', monospace;
  font-size: 14px;
}

.suggestion-item:hover {
  background: #404040;
}

.suggestion-item.selected {
  background: #4CAF50;
  color: #ffffff;
}

.suggestion-item:last-child {
  border-bottom: none;
}

/* Improved terminal input area */
.terminal-input-area {
  position: relative;
}

/* Better cursor visibility */
.cursor {
  color: #ffffff;
  animation: blink 1s infinite;
  font-weight: bold;
  background: #4CAF50;
  padding: 0 1px;
}

/* Selection styling */
.command-input::selection {
  background: #4CAF50;
  color: #ffffff;
}

.command-input::-moz-selection {
  background: #4CAF50;
  color: #ffffff;
}

/* Terminal scrollbar improvements */
.terminal-body::-webkit-scrollbar {
  width: 12px;
}

.terminal-body::-webkit-scrollbar-track {
  background: #2d2d2d;
  border-radius: 6px;
}

.terminal-body::-webkit-scrollbar-thumb {
  background: #404040;
  border-radius: 6px;
  border: 2px solid #2d2d2d;
}

.terminal-body::-webkit-scrollbar-thumb:hover {
  background: #555555;
}

/* Responsive improvements */
@media (max-width: 768px) {
  .command-suggestions {
    max-height: 150px;
  }
  
  .suggestion-item {
    padding: 6px 8px;
    font-size: 12px;
  }
}

/* Loading states */
.terminal-loading {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 100px;
  color: #4CAF50;
}

.terminal-loading .spinner {
  width: 20px;
  height: 20px;
  border: 2px solid #404040;
  border-top: 2px solid #4CAF50;
  border-radius: 50%;
  animation: spin 1s linear infinite;
  margin-right: 10px;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* Error states */
.terminal-error {
  background: #ff6b6b;
  color: #ffffff;
  padding: 10px;
  margin: 10px 0;
  border-radius: 4px;
  font-weight: bold;
}

/* Success states */
.terminal-success {
  background: #4CAF50;
  color: #ffffff;
  padding: 10px;
  margin: 10px 0;
  border-radius: 4px;
  font-weight: bold;
}
</style>

<script src="https://cdn.socket.io/4.7.4/socket.io.min.js"></script>

<script>
// ==========================
// ƒê·ª£i Socket.IO load xong
// ==========================
function waitForSocketIO() {
  return new Promise((resolve, reject) => {
    if (typeof io !== 'undefined') {
      resolve();
    } else {
      // Ki·ªÉm tra m·ªói 100ms v·ªõi timeout 10 gi√¢y
      let attempts = 0;
      const maxAttempts = 100; // 10 gi√¢y
      
      const checkInterval = setInterval(() => {
        attempts++;
        if (typeof io !== 'undefined') {
          clearInterval(checkInterval);
          resolve();
        } else if (attempts >= maxAttempts) {
          clearInterval(checkInterval);
          reject(new Error('Socket.IO failed to load after 10 seconds'));
        }
      }, 100);
    }
  });
}

// ==========================
// Qu·∫£n l√Ω target li√™n k·∫øt
// ==========================
function render_target_info() {
  $.ajax({
    url: `/api/getalltarget`,
    type: 'GET',
    success: function(resp) {
      // X√≥a c√°c option c≈©, ch·ªâ gi·ªØ l·∫°i option ƒë·∫ßu ti√™n
      $('#targetSelect').find('option:not(:first)').remove();
      // Th√™m c√°c target m·ªõi v√†o select
      $.each(resp.targets, function(index, item) {
        $('#targetSelect').append(
          $('<option>', {
            value: item.server_id,
            text: `${item.hostname} (${item.ip_address})`
          })
        );
      });
    },
    error: function(error) {
      console.error('L·ªói khi l·∫•y danh s√°ch target:', error);
    }
  });
}

// ==========================
// Terminal th·∫≠t v·ªõi Socket.IO
// ==========================
let isConnected = false; // Tr·∫°ng th√°i k·∫øt n·ªëi shell
let currentShellId = '{{ shell.connection_id }}';
let currentShellData = null;
let commandHistory = [];
let historyIndex = -1;
let shellReady = false; // Tr·∫°ng th√°i shell ƒë√£ s·∫µn s√†ng
let outputBuffer = ''; // Buffer ƒë·ªÉ x·ª≠ l√Ω output b·ªã chia nh·ªè

// Terminal state management
let cursorPosition = 0; // V·ªã tr√≠ con tr·ªè
let currentCommand = ''; // L·ªánh hi·ªán t·∫°i
let isTyping = false; // ƒêang g√µ
let selectionStart = 0; // V·ªã tr√≠ b·∫Øt ƒë·∫ßu selection
let selectionEnd = 0; // V·ªã tr√≠ k·∫øt th√∫c selection

// Kh·ªüi t·∫°o terminal
function initTerminal() {
  $('#terminalContent').html(`
    <div class="terminal-line">
      
      <span class="command" id="currentCommand"></span>
      <span class="cursor" id="cursor">|</span>
    </div>
  `);
  commandHistory = [];
  historyIndex = -1;
}

// Lo·∫°i b·ªè ANSI escape sequences
function removeAnsi(str) {
  return str
    // X·ª≠ l√Ω t·∫•t c·∫£ ANSI escape sequences
    .replace(/\x1B\[[0-?]*[ -/]*[@-~]/g, '') // ANSI color codes c∆° b·∫£n
    .replace(/\x1B\]8;[^;]*;[^;]*\x07/g, '') // OSC sequences (file links)
    .replace(/\x1B\[[0-9]*[ABCDEFGJKST]/g, '') // Cursor movement
    .replace(/\x1B\[[0-9]*[hl]/g, '') // Mode changes
    .replace(/\x1B\[[0-9]*[JK]/g, '') // Erase operations
    .replace(/\x1B\[[0-9]*[m]/g, '') // Color attributes
    .replace(/\x1B\[[0-9]*[r]/g, '') // Scroll region
    .replace(/\x1B\[[0-9]*[d]/g, '') // Line positioning
    .replace(/\x1B\[[0-9]*[G]/g, '') // Cursor positioning
    .replace(/\x1B\[[0-9]*[H]/g, '') // Cursor positioning
    .replace(/\x1B\[[0-9]*[f]/g, '') // Cursor positioning
    .replace(/\x1B\[[0-9]*[s]/g, '') // Save cursor
    .replace(/\x1B\[[0-9]*[u]/g, '') // Restore cursor
    .replace(/\x1B\[[0-9]*[n]/g, '') // Device status
    .replace(/\x1B\[[0-9]*[c]/g, '') // Device attributes
    .replace(/\x1B\[[0-9]*[y]/g, '') // Device attributes
    .replace(/\x1B\[[0-9]*[q]/g, '') // Device attributes
    .replace(/\x1B\[[0-9]*[p]/g, '') // Device attributes
    .replace(/\x1B\[[0-9]*[g]/g, '') // Tab stops
    .replace(/\x1B\[[0-9]*[i]/g, '') // Print
    .replace(/\x1B\[[0-9]*[Z]/g, '') // Tab backward
    .replace(/\x1B\[[0-9]*[@]/g, '') // Insert characters
    .replace(/\x1B\[[0-9]*[P]/g, '') // Delete characters
    .replace(/\x1B\[[0-9]*[X]/g, '') // Erase characters
    .replace(/\x1B\[[0-9]*[L]/g, '') // Insert lines
    .replace(/\x1B\[[0-9]*[M]/g, '') // Delete lines
    .replace(/\x1B\[[0-9]*[T]/g, '') // Scroll down
    .replace(/\x1B\[[0-9]*[S]/g, '') // Scroll up
    .replace(/\x1B\[[0-9]*[b]/g, '') // Repeat character
    .replace(/\x1B\[[0-9]*[a]/g, '') // Cursor up
    .replace(/\x1B\[[0-9]*[e]/g, '') // Cursor down
    .replace(/\x1B\[[0-9]*[C]/g, '') // Cursor forward
    .replace(/\x1B\[[0-9]*[D]/g, '') // Cursor backward
    // X·ª≠ l√Ω c√°c escape sequences ph·ª©c t·∫°p h∆°n
    .replace(/\x1B\[[0-9;]*[ABCDEFGJKST]/g, '') // Cursor movement v·ªõi parameters
    .replace(/\x1B\[[0-9;]*[hl]/g, '') // Mode changes v·ªõi parameters
    .replace(/\x1B\[[0-9;]*[JK]/g, '') // Erase operations v·ªõi parameters
    .replace(/\x1B\[[0-9;]*[m]/g, '') // Color attributes v·ªõi parameters
    .replace(/\x1B\[[0-9;]*[r]/g, '') // Scroll region v·ªõi parameters
    .replace(/\x1B\[[0-9;]*[d]/g, '') // Line positioning v·ªõi parameters
    .replace(/\x1B\[[0-9;]*[G]/g, '') // Cursor positioning v·ªõi parameters
    .replace(/\x1B\[[0-9;]*[H]/g, '') // Cursor positioning v·ªõi parameters
    .replace(/\x1B\[[0-9;]*[f]/g, '') // Cursor positioning v·ªõi parameters
    .replace(/\x1B\[[0-9;]*[s]/g, '') // Save cursor v·ªõi parameters
    .replace(/\x1B\[[0-9;]*[u]/g, '') // Restore cursor v·ªõi parameters
    .replace(/\x1B\[[0-9;]*[n]/g, '') // Device status v·ªõi parameters
    .replace(/\x1B\[[0-9;]*[c]/g, '') // Device attributes v·ªõi parameters
    .replace(/\x1B\[[0-9;]*[y]/g, '') // Device attributes v·ªõi parameters
    .replace(/\x1B\[[0-9;]*[q]/g, '') // Device attributes v·ªõi parameters
    .replace(/\x1B\[[0-9;]*[p]/g, '') // Device attributes v·ªõi parameters
    .replace(/\x1B\[[0-9;]*[g]/g, '') // Tab stops v·ªõi parameters
    .replace(/\x1B\[[0-9;]*[i]/g, '') // Print v·ªõi parameters
    .replace(/\x1B\[[0-9;]*[Z]/g, '') // Tab backward v·ªõi parameters
    .replace(/\x1B\[[0-9;]*[@]/g, '') // Insert characters v·ªõi parameters
    .replace(/\x1B\[[0-9;]*[P]/g, '') // Delete characters v·ªõi parameters
    .replace(/\x1B\[[0-9;]*[X]/g, '') // Erase characters v·ªõi parameters
    .replace(/\x1B\[[0-9;]*[L]/g, '') // Insert lines v·ªõi parameters
    .replace(/\x1B\[[0-9;]*[M]/g, '') // Delete lines v·ªõi parameters
    .replace(/\x1B\[[0-9;]*[T]/g, '') // Scroll down v·ªõi parameters
    .replace(/\x1B\[[0-9;]*[S]/g, '') // Scroll up v·ªõi parameters
    .replace(/\x1B\[[0-9;]*[b]/g, '') // Repeat character v·ªõi parameters
    .replace(/\x1B\[[0-9;]*[a]/g, '') // Cursor up v·ªõi parameters
    .replace(/\x1B\[[0-9;]*[e]/g, '') // Cursor down v·ªõi parameters
    .replace(/\x1B\[[0-9;]*[C]/g, '') // Cursor forward v·ªõi parameters
    .replace(/\x1B\[[0-9;]*[D]/g, '') // Cursor backward v·ªõi parameters
    // X·ª≠ l√Ω c√°c escape sequences ƒë·∫∑c bi·ªát
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[hl]/g, '') // Private mode changes
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[JK]/g, '') // Private erase operations
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[m]/g, '') // Private color attributes
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[r]/g, '') // Private scroll region
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[d]/g, '') // Private line positioning
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[G]/g, '') // Private cursor positioning
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[H]/g, '') // Private cursor positioning
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[f]/g, '') // Private cursor positioning
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[s]/g, '') // Private save cursor
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[u]/g, '') // Private restore cursor
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[n]/g, '') // Private device status
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[c]/g, '') // Private device attributes
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[y]/g, '') // Private device attributes
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[q]/g, '') // Private device attributes
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[p]/g, '') // Private device attributes
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[g]/g, '') // Private tab stops
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[i]/g, '') // Private print
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[Z]/g, '') // Private tab backward
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[@]/g, '') // Private insert characters
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[P]/g, '') // Private delete characters
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[X]/g, '') // Private erase characters
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[L]/g, '') // Private insert lines
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[M]/g, '') // Private delete lines
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[T]/g, '') // Private scroll down
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[S]/g, '') // Private scroll up
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[b]/g, '') // Private repeat character
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[a]/g, '') // Private cursor up
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[e]/g, '') // Private cursor down
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[C]/g, '') // Private cursor forward
    .replace(/\x1B\[[0-9;]*[?][0-9;]*[D]/g, '') // Private cursor backward
    // X·ª≠ l√Ω c√°c escape sequences kh√°c
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[hl]/g, '') // Secondary mode changes
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[JK]/g, '') // Secondary erase operations
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[m]/g, '') // Secondary color attributes
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[r]/g, '') // Secondary scroll region
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[d]/g, '') // Secondary line positioning
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[G]/g, '') // Secondary cursor positioning
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[H]/g, '') // Secondary cursor positioning
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[f]/g, '') // Secondary cursor positioning
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[s]/g, '') // Secondary save cursor
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[u]/g, '') // Secondary restore cursor
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[n]/g, '') // Secondary device status
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[c]/g, '') // Secondary device attributes
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[y]/g, '') // Secondary device attributes
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[q]/g, '') // Secondary device attributes
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[p]/g, '') // Secondary device attributes
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[g]/g, '') // Secondary tab stops
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[i]/g, '') // Secondary print
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[Z]/g, '') // Secondary tab backward
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[@]/g, '') // Secondary insert characters
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[P]/g, '') // Secondary delete characters
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[X]/g, '') // Secondary erase characters
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[L]/g, '') // Secondary insert lines
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[M]/g, '') // Secondary delete lines
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[T]/g, '') // Secondary scroll down
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[S]/g, '') // Secondary scroll up
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[b]/g, '') // Secondary repeat character
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[a]/g, '') // Secondary cursor up
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[e]/g, '') // Secondary cursor down
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[C]/g, '') // Secondary cursor forward
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[D]/g, '') // Secondary cursor backward
    // X·ª≠ l√Ω c√°c escape sequences cu·ªëi c√πng
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[hl]/g, '') // Tertiary mode changes
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[JK]/g, '') // Tertiary erase operations
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[m]/g, '') // Tertiary color attributes
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[r]/g, '') // Tertiary scroll region
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[d]/g, '') // Tertiary line positioning
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[G]/g, '') // Tertiary cursor positioning
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[H]/g, '') // Tertiary cursor positioning
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[f]/g, '') // Tertiary cursor positioning
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[s]/g, '') // Tertiary save cursor
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[u]/g, '') // Tertiary restore cursor
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[n]/g, '') // Tertiary device status
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[c]/g, '') // Tertiary device attributes
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[y]/g, '') // Tertiary device attributes
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[q]/g, '') // Tertiary device attributes
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[p]/g, '') // Tertiary device attributes
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[g]/g, '') // Tertiary tab stops
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[i]/g, '') // Tertiary print
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[Z]/g, '') // Tertiary tab backward
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[@]/g, '') // Tertiary insert characters
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[P]/g, '') // Tertiary delete characters
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[X]/g, '') // Tertiary erase characters
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[L]/g, '') // Tertiary insert lines
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[M]/g, '') // Tertiary delete lines
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[T]/g, '') // Tertiary scroll down
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[S]/g, '') // Tertiary scroll up
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[b]/g, '') // Tertiary repeat character
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[a]/g, '') // Tertiary cursor up
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[e]/g, '') // Tertiary cursor down
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[C]/g, '') // Tertiary cursor forward
    .replace(/\x1B\[[0-9;]*[=][0-9;]*[D]/g, '') // Tertiary cursor backward
    // X·ª≠ l√Ω c√°c escape sequences ƒë·∫∑c bi·ªát kh√°c
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[hl]/g, '') // Special mode changes
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[JK]/g, '') // Special erase operations
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[m]/g, '') // Special color attributes
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[r]/g, '') // Special scroll region
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[d]/g, '') // Special line positioning
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[G]/g, '') // Special cursor positioning
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[H]/g, '') // Special cursor positioning
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[f]/g, '') // Special cursor positioning
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[s]/g, '') // Special save cursor
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[u]/g, '') // Special restore cursor
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[n]/g, '') // Special device status
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[c]/g, '') // Special device attributes
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[y]/g, '') // Special device attributes
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[q]/g, '') // Special device attributes
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[p]/g, '') // Special device attributes
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[g]/g, '') // Special tab stops
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[i]/g, '') // Special print
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[Z]/g, '') // Special tab backward
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[@]/g, '') // Special insert characters
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[P]/g, '') // Special delete characters
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[X]/g, '') // Special erase characters
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[L]/g, '') // Special insert lines
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[M]/g, '') // Special delete lines
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[T]/g, '') // Special scroll down
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[S]/g, '') // Special scroll up
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[b]/g, '') // Special repeat character
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[a]/g, '') // Special cursor up
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[e]/g, '') // Special cursor down
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[C]/g, '') // Special cursor forward
    .replace(/\x1B\[[0-9;]*[!][0-9;]*[D]/g, '') // Special cursor backward
    // X·ª≠ l√Ω c√°c escape sequences cu·ªëi c√πng
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[hl]/g, '') // Complex mode changes
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[JK]/g, '') // Complex erase operations
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[m]/g, '') // Complex color attributes
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[r]/g, '') // Complex scroll region
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[d]/g, '') // Complex line positioning
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[G]/g, '') // Complex cursor positioning
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[H]/g, '') // Complex cursor positioning
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[f]/g, '') // Complex cursor positioning
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[s]/g, '') // Complex save cursor
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[u]/g, '') // Complex restore cursor
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[n]/g, '') // Complex device status
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[c]/g, '') // Complex device attributes
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[y]/g, '') // Complex device attributes
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[q]/g, '') // Complex device attributes
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[p]/g, '') // Complex device attributes
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[g]/g, '') // Complex tab stops
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[i]/g, '') // Complex print
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[Z]/g, '') // Complex tab backward
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[@]/g, '') // Complex insert characters
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[P]/g, '') // Complex delete characters
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[X]/g, '') // Complex erase characters
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[L]/g, '') // Complex insert lines
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[M]/g, '') // Complex delete lines
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[T]/g, '') // Complex scroll down
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[S]/g, '') // Complex scroll up
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[b]/g, '') // Complex repeat character
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[a]/g, '') // Complex cursor up
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[e]/g, '') // Complex cursor down
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[C]/g, '') // Complex cursor forward
    .replace(/\x1B\[[0-9;]*[>][0-9;]*[?][0-9;]*[D]/g, ''); // Complex cursor backward
}

// In output ra terminal
function printOutput(output, type = 'normal') {
  const terminalContent = $('#terminalContent');
  
  // Lo·∫°i b·ªè ANSI escape sequences ƒë·ªÉ hi·ªÉn th·ªã text s·∫°ch
  const cleanOutput = removeAnsi(output);
  
  // S·ª≠ d·ª•ng pre ƒë·ªÉ gi·ªØ nguy√™n format v√† whitespace
  const outputDiv = $('<div>', {
    class: `output-line ${type === 'error' ? 'error-line' : type === 'success' ? 'success-line' : ''}`
  }).html(`<pre style="margin: 0; font-family: inherit; white-space: pre-wrap;">${cleanOutput}</pre>`);
  
  terminalContent.append(outputDiv);
  
  // Scroll xu·ªëng cu·ªëi
  const terminalBody = $('#terminalOutput');
  terminalBody.scrollTop(terminalBody[0].scrollHeight);
}

// In prompt m·ªõi
function printPrompt() {
  const terminalContent = $('#terminalContent');
  
  // Ki·ªÉm tra xem ƒë√£ c√≥ prompt ·ªü cu·ªëi ch∆∞a
  const lastChild = terminalContent.children().last();
  if (lastChild.length && lastChild.hasClass('terminal-line')) {
    // ƒê√£ c√≥ prompt, kh√¥ng c·∫ßn t·∫°o m·ªõi
    return;
  }
  
  const promptDiv = $('<div>', {
    class: 'terminal-line'
  }).html(`
    <span class="command" id="currentCommand"></span>
    <span class="cursor" id="cursor">|</span>
  `);
  terminalContent.append(promptDiv);
  
  // Scroll xu·ªëng cu·ªëi
  const terminalBody = $('#terminalOutput');
  terminalBody.scrollTop(terminalBody[0].scrollHeight);
  
  // Focus v√†o input
  focusInput();
}

// Focus v√†o input terminal
function focusInput() {
  const input = $('#commandInput');
  input.focus();
  
  // ƒê·∫∑t con tr·ªè ·ªü cu·ªëi
  const range = document.createRange();
  const selection = window.getSelection();
  range.selectNodeContents(input[0]);
  range.collapse(false);
  selection.removeAllRanges();
  selection.addRange(range);
  
  cursorPosition = currentCommand.length;
  updateCursor();
}

// C·∫≠p nh·∫≠t v·ªã tr√≠ con tr·ªè
function updateCursor() {
  const input = $('#commandInput');
  const text = input.text();
  
  // T·∫°o range ƒë·ªÉ ƒë·∫∑t con tr·ªè
  const range = document.createRange();
  const selection = window.getSelection();
  
  if (cursorPosition <= text.length) {
    let node = input[0].firstChild;
    if (!node) {
      node = document.createTextNode('');
      input[0].appendChild(node);
    }
    
    range.setStart(node, Math.min(cursorPosition, text.length));
    range.setEnd(node, Math.min(cursorPosition, text.length));
    
    selection.removeAllRanges();
    selection.addRange(range);
  }
}

// X·ª≠ l√Ω ph√≠m t·∫Øt
function handleKeyDown(e) {
  const key = e.key;
  const ctrl = e.ctrlKey;
  const shift = e.shiftKey;
  const alt = e.altKey;
  
  console.log('[DEBUG] Key pressed:', key, 'Ctrl:', ctrl, 'Shift:', shift, 'Alt:', alt);
  
  // Enter - G·ª≠i l·ªánh
  if (key === 'Enter') {
    e.preventDefault();
    const command = $('#commandInput').text().trim();
    if (command) {
      sendCommandToShell(command);
      $('#commandInput').text('');
      currentCommand = '';
      cursorPosition = 0;
    }
    return;
  }
  
  // Tab - Auto-completion ho·∫∑c indent
  if (key === 'Tab') {
    e.preventDefault();
    if (shift) {
      // Shift+Tab - Unindent
      insertText('    ');
    } else {
      // Tab - Indent ho·∫∑c auto-completion
      insertText('    ');
    }
    return;
  }
  
  // Arrow keys
  if (key === 'ArrowLeft') {
    e.preventDefault();
    if (ctrl) {
      // Ctrl+Left - Word left
      moveCursorWordLeft();
    } else {
      // Left - Character left
      cursorPosition = Math.max(0, cursorPosition - 1);
      updateCursor();
    }
    return;
  }
  
  if (key === 'ArrowRight') {
    e.preventDefault();
    if (ctrl) {
      // Ctrl+Right - Word right
      moveCursorWordRight();
    } else {
      // Right - Character right
      cursorPosition = Math.min(currentCommand.length, cursorPosition + 1);
      updateCursor();
    }
    return;
  }
  
  if (key === 'ArrowUp') {
    e.preventDefault();
    if (ctrl) {
      // Ctrl+Up - Scroll up
      scrollTerminalUp();
    } else {
      // Up - History up
      navigateHistoryUp();
    }
    return;
  }
  
  if (key === 'ArrowDown') {
    e.preventDefault();
    if (ctrl) {
      // Ctrl+Down - Scroll down
      scrollTerminalDown();
    } else {
      // Down - History down
      navigateHistoryDown();
    }
    return;
  }
  
  // Home/End
  if (key === 'Home') {
    e.preventDefault();
    if (ctrl) {
      // Ctrl+Home - Start of terminal
      scrollTerminalToTop();
    } else {
      // Home - Start of line
      cursorPosition = 0;
      updateCursor();
    }
    return;
  }
  
  if (key === 'End') {
    e.preventDefault();
    if (ctrl) {
      // Ctrl+End - End of terminal
      scrollTerminalToBottom();
    } else {
      // End - End of line
      cursorPosition = currentCommand.length;
      updateCursor();
    }
    return;
  }
  
  // Ctrl+A - Select all
  if (ctrl && key === 'a') {
    e.preventDefault();
    selectAll();
    return;
  }
  
  // Ctrl+C - Copy
  if (ctrl && key === 'c') {
    e.preventDefault();
    copySelection();
    return;
  }
  
  // Ctrl+V - Paste
  if (ctrl && key === 'v') {
    e.preventDefault();
    pasteFromClipboard();
    return;
  }
  
  // Ctrl+X - Cut
  if (ctrl && key === 'x') {
    e.preventDefault();
    cutSelection();
    return;
  }
  
  // Ctrl+L - Clear screen
  if (ctrl && key === 'l') {
    e.preventDefault();
    clearTerminal();
    return;
  }
  
  // Ctrl+U - Clear line before cursor
  if (ctrl && key === 'u') {
    e.preventDefault();
    clearLineBeforeCursor();
    return;
  }
  
  // Ctrl+K - Clear line after cursor
  if (ctrl && key === 'k') {
    e.preventDefault();
    clearLineAfterCursor();
    return;
  }
  
  // Ctrl+W - Delete word before cursor
  if (ctrl && key === 'w') {
    e.preventDefault();
    deleteWordBeforeCursor();
    return;
  }
  
  // Backspace
  if (key === 'Backspace') {
    e.preventDefault();
    if (cursorPosition > 0) {
      currentCommand = currentCommand.slice(0, cursorPosition - 1) + currentCommand.slice(cursorPosition);
      cursorPosition--;
      $('#commandInput').text(currentCommand);
      updateCursor();
    }
    return;
  }
  
  // Delete
  if (key === 'Delete') {
    e.preventDefault();
    if (cursorPosition < currentCommand.length) {
      currentCommand = currentCommand.slice(0, cursorPosition) + currentCommand.slice(cursorPosition + 1);
      $('#commandInput').text(currentCommand);
      updateCursor();
    }
    return;
  }
  
  // Escape - Clear current line
  if (key === 'Escape') {
    e.preventDefault();
    currentCommand = '';
    cursorPosition = 0;
    $('#commandInput').text('');
    updateCursor();
    return;
  }
}

// C√°c h√†m h·ªó tr·ª£
function insertText(text) {
  currentCommand = currentCommand.slice(0, cursorPosition) + text + currentCommand.slice(cursorPosition);
  cursorPosition += text.length;
  $('#commandInput').text(currentCommand);
  updateCursor();
}

function moveCursorWordLeft() {
  const words = currentCommand.split(/\s+/);
  let pos = 0;
  for (let i = 0; i < words.length; i++) {
    if (pos + words[i].length >= cursorPosition) {
      cursorPosition = pos;
      break;
    }
    pos += words[i].length + 1;
  }
  updateCursor();
}

function moveCursorWordRight() {
  const words = currentCommand.split(/\s+/);
  let pos = 0;
  for (let i = 0; i < words.length; i++) {
    pos += words[i].length + 1;
    if (pos > cursorPosition) {
      cursorPosition = pos - 1;
      break;
    }
  }
  updateCursor();
}

function navigateHistoryUp() {
  if (historyIndex > 0) {
    historyIndex--;
    currentCommand = commandHistory[historyIndex];
    cursorPosition = currentCommand.length;
    $('#commandInput').text(currentCommand);
    updateCursor();
  }
}

function navigateHistoryDown() {
  if (historyIndex < commandHistory.length - 1) {
    historyIndex++;
    currentCommand = commandHistory[historyIndex];
    cursorPosition = currentCommand.length;
    $('#commandInput').text(currentCommand);
    updateCursor();
  } else if (historyIndex === commandHistory.length - 1) {
    historyIndex++;
    currentCommand = '';
    cursorPosition = 0;
    $('#commandInput').text('');
    updateCursor();
  }
}

function scrollTerminalUp() {
  const terminalBody = $('#terminalOutput');
  terminalBody.scrollTop(terminalBody.scrollTop() - 50);
}

function scrollTerminalDown() {
  const terminalBody = $('#terminalOutput');
  terminalBody.scrollTop(terminalBody.scrollTop() + 50);
}

function scrollTerminalToTop() {
  const terminalBody = $('#terminalOutput');
  terminalBody.scrollTop(0);
}

function scrollTerminalToBottom() {
  const terminalBody = $('#terminalOutput');
  terminalBody.scrollTop(terminalBody[0].scrollHeight);
}

function selectAll() {
  const input = $('#commandInput');
  const range = document.createRange();
  const selection = window.getSelection();
  range.selectNodeContents(input[0]);
  selection.removeAllRanges();
  selection.addRange(range);
}

function copySelection() {
  const selection = window.getSelection();
  if (selection.toString()) {
    navigator.clipboard.writeText(selection.toString());
  }
}

function pasteFromClipboard() {
  navigator.clipboard.readText().then(text => {
    insertText(text);
  });
}

function cutSelection() {
  const selection = window.getSelection();
  if (selection.toString()) {
    navigator.clipboard.writeText(selection.toString());
    // X√≥a selection
    const range = selection.getRangeAt(0);
    range.deleteContents();
  }
}

function clearTerminal() {
  $('#terminalContent').empty();
  if (isConnected) {
    printPrompt();
  } else {
    printOutput('ƒêang ch·ªù k·∫øt n·ªëi reverse shell...');
  }
}

function clearLineBeforeCursor() {
  currentCommand = currentCommand.slice(cursorPosition);
  cursorPosition = 0;
  $('#commandInput').text(currentCommand);
  updateCursor();
}

function clearLineAfterCursor() {
  currentCommand = currentCommand.slice(cursorPosition);
  $('#commandInput').text(currentCommand);
  updateCursor();
}

function deleteWordBeforeCursor() {
  const beforeCursor = currentCommand.slice(0, cursorPosition);
  const afterCursor = currentCommand.slice(cursorPosition);
  const words = beforeCursor.split(/\s+/);
  if (words.length > 1) {
    words.pop();
    const newBefore = words.join(' ');
    currentCommand = newBefore + afterCursor;
    cursorPosition = newBefore.length;
    $('#commandInput').text(currentCommand);
    updateCursor();
  }
}

// ==========================
// T√≠ch h·ª£p Socket.IO cho realtime shell
// ==========================
let socket = null;

// Kh·ªüi t·∫°o Socket.IO khi ƒë√£ s·∫µn s√†ng
async function initializeSocketIO() {
  console.log('[DEBUG] Waiting for Socket.IO to load...');
  try {
    await waitForSocketIO();
    console.log('[DEBUG] Socket.IO loaded, initializing connection...');
    
    socket = io.connect('http://' + document.domain + ':' + location.port);
    console.log('[DEBUG] Socket connection created');

// Khi k·∫øt n·ªëi socket th√†nh c√¥ng
socket.on('connect', function() {
      console.log('[DEBUG] Socket connected successfully');
  printOutput('ƒê√£ k·∫øt n·ªëi t·ªõi server Socket.IO', 'success');
  // Tham gia room shell hi·ªán t·∫°i
  socket.emit('join_shell', { shell_id: currentShellId });
      
      // Ki·ªÉm tra xem shell ƒë√£ connected ch∆∞a
      if (isConnected && shellReady) {
        console.log('[DEBUG] Socket connected and shell is ready, initializing terminal');
        initializeTerminalForConnectedShell();
      }
    });
    
    // Khi socket disconnect
    socket.on('disconnect', function() {
      console.log('[DEBUG] Socket disconnected');
      printOutput('M·∫•t k·∫øt n·ªëi t·ªõi server Socket.IO', 'error');
    });
    
    // Khi socket error
    socket.on('connect_error', function(error) {
      console.error('[DEBUG] Socket connection error:', error);
      printOutput('L·ªói k·∫øt n·ªëi Socket.IO: ' + error, 'error');
});

// Nh·∫≠n th√¥ng b√°o shell ƒë√£ k·∫øt n·ªëi
socket.on('shell_connected', function(data) {
  console.log('[DEBUG] Received shell_connected:', data);
  if (data.shell_id !== currentShellId) return;
  
  // Hi·ªÉn th·ªã th√¥ng b√°o k·∫øt n·ªëi ƒë·∫∑c bi·ªát
  printOutput('üéâ ' + (data.message || 'Shell connected successfully!'), 'success');
  
  // C·∫≠p nh·∫≠t tr·∫°ng th√°i
  isConnected = true;
  shellReady = true;
  
  // C·∫≠p nh·∫≠t UI
  $('#shellStatus').removeClass('bg-warning bg-secondary bg-danger').addClass('bg-success').text('Connected');
  $('#commandInput').prop('disabled', false);
  $('#disconnectShell').prop('disabled', false);
  
  // Focus v√†o input
  setTimeout(() => {
    focusInput();
  }, 100);
  
  // Hi·ªÉn th·ªã th√¥ng b√°o toast
  showToast('success', 'Shell Connected!', 'Shell is now active and ready for interaction!');
});

// Nh·∫≠n c·∫≠p nh·∫≠t tr·∫°ng th√°i shell t·ª´ server (realtime)
socket.on('shell_status_update', function(data) {
  console.log('[DEBUG] Received shell_status_update:', data);
  if (data.shell_id !== currentShellId) return;
  updateToggleShellBtn(data.status);
  $('#shellStatus').removeClass('bg-success bg-warning bg-secondary bg-danger');
  if (data.status === 'CLOSED') {
    $('#shellStatus').addClass('bg-secondary').text('Closed');
    isConnected = false;
    shellReady = false;
    outputBuffer = '';
    initTerminal();
    printOutput('Shell ƒë√£ ƒë√≥ng. Nh·∫•n "B·∫≠t Shell" ƒë·ªÉ k·∫øt n·ªëi l·∫°i.');
  } else if (data.status === 'LISTENING') {
    $('#shellStatus').addClass('bg-warning').text('Listening');
    isConnected = false;
    shellReady = false;
    outputBuffer = '';
    initTerminal();
    printOutput('ƒêang ch·ªù k·∫øt n·ªëi reverse shell...');
  } else if (data.status === 'CONNECTED') {
    console.log('[DEBUG] Shell connected, setting isConnected = true');
    $('#shellStatus').addClass('bg-success').text('Connected');
    isConnected = true;
        
        // Ki·ªÉm tra xem terminal ƒë√£ ƒë∆∞·ª£c kh·ªüi t·∫°o ch∆∞a
    if (!$('#terminalContent').children().length) {
      // Ch·ªâ init terminal n·∫øu ch∆∞a c√≥ n·ªôi dung
      initTerminal();
      printOutput('Shell ƒë√£ k·∫øt n·ªëi th√†nh c√¥ng!', 'success');
    }
        
    // Kh√¥ng in prompt ngay, ƒë·ª£i output t·ª´ pwncat
    // Focus v√†o input khi k·∫øt n·ªëi th√†nh c√¥ng
    $('#commandInput').focus();
    
    // Enable input khi shell ƒë√£ k·∫øt n·ªëi
    $('#commandInput').prop('disabled', false);
    $('#sendCommand').prop('disabled', false);
        $('#disconnectShell').prop('disabled', false);
    
    // Auto-set shellReady sau 3 gi√¢y n·∫øu ch∆∞a ƒë∆∞·ª£c set
    setTimeout(() => {
      if (!shellReady && isConnected) {
        console.log('[DEBUG] Auto-setting shellReady after timeout');
        shellReady = true;
      }
    }, 3000);
  } else if (data.status === 'ERROR') {
    $('#shellStatus').addClass('bg-danger').text('Error');
    isConnected = false;
    shellReady = false;
    outputBuffer = '';
    printOutput(`L·ªói: ${data.error || 'Unknown error'}`, 'error');
  }
  // Enable/disable disconnect button theo tr·∫°ng th√°i
  $('#disconnectShell').prop('disabled', !isConnected);
  $('#commandInput').prop('disabled', !isConnected);
  $('#sendCommand').prop('disabled', !isConnected);
});

// Nh·∫≠n output t·ª´ shell (realtime) - PTY mode
socket.on('terminal_output', function(data) {
  console.log('[DEBUG] Received terminal_output:', data);
      if (data.shell_id !== currentShellId) {
        console.log('[DEBUG] Ignoring output for different shell:', data.shell_id);
        return;
      }
  if (data.output) {
    console.log('[DEBUG] Writing to terminal:', JSON.stringify(data.output));
    
    // Th√™m output v√†o buffer
    outputBuffer += data.output;
    
    // Ki·ªÉm tra xem buffer c√≥ ch·ª©a warning kh√¥ng
    const cleanBuffer = removeAnsi(outputBuffer);
    if (cleanBuffer.includes('WARNING: your terminal doesn\'t support cursor position requests (CPR).')) {
      // B·ªè qua warning n√†y, kh√¥ng hi·ªÉn th·ªã
          console.log('[DEBUG] Skipping CPR warning');
      outputBuffer = '';
      return;
    }
    
    // Ki·ªÉm tra xem buffer c√≥ ch·ª©a prompt kh√¥ng (pwncat prompt)
    if (cleanBuffer.includes('pwncat$') || cleanBuffer.includes('(local) pwncat$')) {
      // ƒê√£ nh·∫≠n prompt t·ª´ pwncat, shell ƒë√£ s·∫µn s√†ng
      shellReady = true;
      console.log('[DEBUG] Shell ready detected from prompt');
      
      // In buffer v√† reset
      if (outputBuffer.trim()) {
        printOutput(outputBuffer);
      }
      outputBuffer = '';
      
      // Ch·ªâ in prompt n·∫øu ch∆∞a c√≥ prompt ·ªü cu·ªëi
      const terminalContent = $('#terminalContent');
      const lastChild = terminalContent.children().last();
      if (!lastChild.length || !lastChild.hasClass('terminal-line')) {
        setTimeout(() => printPrompt(), 100);
      }
          
          // Enable input n·∫øu ch∆∞a ƒë∆∞·ª£c enable
          if ($('#commandInput').prop('disabled')) {
            console.log('[DEBUG] Enabling input after prompt detection');
            $('#commandInput').prop('disabled', false);
            $('#disconnectShell').prop('disabled', false);
            focusInput();
          }
          
        } else if (cleanBuffer.includes('registered new host') && !shellReady) {
      // ƒê√£ nh·∫≠n th√¥ng b√°o host ƒë∆∞·ª£c ƒëƒÉng k√Ω, shell g·∫ßn nh∆∞ s·∫µn s√†ng
      console.log('[DEBUG] Host registered detected, shell almost ready');
      // Kh√¥ng set shellReady ngay, ƒë·ª£i prompt
    } else {
      // Ki·ªÉm tra xem c√≥ ph·∫£i l√† output ho√†n ch·ªânh kh√¥ng (c√≥ newline)
      if (outputBuffer.includes('\n') || outputBuffer.includes('\r')) {
        // In buffer v√† reset
        if (outputBuffer.trim()) {
          printOutput(outputBuffer);
        }
        outputBuffer = '';
      }
    }
  }
});

// Nh·∫≠n terminal data m·ªõi (c·∫£i ti·∫øn)
socket.on('terminal_data', function(data) {
  console.log('[DEBUG] Received terminal_data:', data);
  if (data.shell_id !== currentShellId) return;
  
  if (data.type === 'connection_notice') {
    // Hi·ªÉn th·ªã th√¥ng b√°o k·∫øt n·ªëi ƒë·∫∑c bi·ªát
    printOutput('üéâ ' + (data.message || 'Shell connected!'), 'success');
    showToast('success', 'Shell Connected!', 'Shell is now active and ready for interaction!');
  } else if (data.type === 'output') {
    // X·ª≠ l√Ω output th√¥ng th∆∞·ªùng
    if (data.data) {
      outputBuffer += data.data;
      
      // Ki·ªÉm tra prompt v√† x·ª≠ l√Ω nh∆∞ c≈©
      const cleanBuffer = removeAnsi(outputBuffer);
      if (cleanBuffer.includes('pwncat$') || cleanBuffer.includes('(local) pwncat$')) {
        shellReady = true;
        if (outputBuffer.trim()) {
          printOutput(outputBuffer);
        }
        outputBuffer = '';
        
        const terminalContent = $('#terminalContent');
        const lastChild = terminalContent.children().last();
        if (!lastChild.length || !lastChild.hasClass('terminal-line')) {
          setTimeout(() => printPrompt(), 100);
        }
        
        if ($('#commandInput').prop('disabled')) {
          $('#commandInput').prop('disabled', false);
          $('#disconnectShell').prop('disabled', false);
          focusInput();
        }
      } else if (outputBuffer.includes('\n') || outputBuffer.includes('\r')) {
        if (outputBuffer.trim()) {
          printOutput(outputBuffer);
        }
        outputBuffer = '';
      }
    }
  }
});
    
    // Nh·∫≠n th√¥ng b√°o ƒë√£ tham gia shell room
    socket.on('joined_shell', function(data) {
      console.log('[DEBUG] Joined shell room:', data);
      if (data.shell_id === currentShellId) {
        console.log('[DEBUG] Successfully joined shell room for:', currentShellId);
        
        // Ki·ªÉm tra xem shell ƒë√£ connected ch∆∞a
        if (isConnected && shellReady) {
          console.log('[DEBUG] Shell is already connected, initializing terminal');
          initializeTerminalForConnectedShell();
        }
      }
    });
    
    console.log('[DEBUG] Socket.IO initialization completed');
  } catch (error) {
    console.error('[DEBUG] Error initializing Socket.IO:', error);
    printOutput('L·ªói kh·ªüi t·∫°o Socket.IO: ' + error.message, 'error');
    
    // Fallback: t·∫°o socket ƒë∆°n gi·∫£n
    try {
      socket = io.connect('http://' + document.domain + ':' + location.port);
      console.log('[DEBUG] Fallback socket created');
    } catch (fallbackError) {
      console.error('[DEBUG] Fallback socket also failed:', fallbackError);
    }
  }
}

// ==========================
// C√°c h√†m thao t√°c shell
// ==========================

// G·ª≠i y√™u c·∫ßu join shell (khi b·∫≠t shell)
function connectToShell(shellId) {
  console.log('[DEBUG] connectToShell called for:', shellId);
  
  if (!socket) {
    console.log('[DEBUG] Socket not initialized, cannot connect to shell');
    return;
  }
  
  // Tham gia shell room
  socket.emit('join_shell', { shell_id: shellId });
  
  // Ki·ªÉm tra xem shell ƒë√£ connected ch∆∞a
  if (isConnected && shellReady) {
    console.log('[DEBUG] Shell already connected and ready, no need to start');
    return;
  }
  
  // G·ª≠i request b·∫≠t shell qua socket (ch·ªâ khi ch∆∞a connected)
  socket.emit('shell_start', { shell_id: shellId });
}

// H√†m ki·ªÉm tra v√† kh·ªüi t·∫°o terminal cho shell ƒë√£ connected
function initializeTerminalForConnectedShell() {
  console.log('[DEBUG] Initializing terminal for connected shell');
  console.log('[DEBUG] Current state - isConnected:', isConnected, 'shellReady:', shellReady);
  
  // Kh·ªüi t·∫°o terminal n·∫øu ch∆∞a c√≥
  if (!$('#terminalContent').children().length) {
    console.log('[DEBUG] Terminal content is empty, initializing...');
    initTerminal();
  } else {
    console.log('[DEBUG] Terminal content already exists');
  }
  
  // Enable input
  console.log('[DEBUG] Enabling input elements...');
  $('#commandInput').prop('disabled', false);
  $('#disconnectShell').prop('disabled', false);
  
  // Focus v√†o input
  console.log('[DEBUG] Setting focus to input...');
  setTimeout(() => {
    focusInput();
    console.log('[DEBUG] Focus set to input');
  }, 100);
  
  // In th√¥ng b√°o s·∫µn s√†ng
  printOutput('Shell ƒë√£ s·∫µn s√†ng. B·∫°n c√≥ th·ªÉ b·∫Øt ƒë·∫ßu nh·∫≠p l·ªánh!', 'success');
  
  // Set shellReady
  shellReady = true;
  isConnected = true;
  
  console.log('[DEBUG] Terminal initialized for connected shell - isConnected:', isConnected, 'shellReady:', shellReady);
}

// G·ª≠i l·ªánh t·ªõi shell qua socket (PTY mode)
function sendCommandToShell(command) {
  console.log('[DEBUG] sendCommandToShell called with:', command);
  console.log('[DEBUG] Current state - isConnected:', isConnected, 'shellReady:', shellReady);
  
  if (!socket) {
    console.log('[DEBUG] Socket not initialized, cannot send command');
    printOutput('Socket ch∆∞a k·∫øt n·ªëi!', 'error');
    return;
  }
  
  if (!currentShellId || !isConnected) {
    console.log('[DEBUG] Shell not connected, cannot send command');
    printOutput('Shell ch∆∞a k·∫øt n·ªëi!', 'error');
    return;
  }
  
  // Ki·ªÉm tra shellReady, nh∆∞ng n·∫øu ƒë√£ connected th√¨ v·∫´n cho ph√©p g·ª≠i l·ªánh
  if (!shellReady && isConnected) {
    console.log('[DEBUG] Shell connected but not ready, attempting to send command anyway');
  }
  
  // Th√™m l·ªánh v√†o history
  if (command.trim()) {
    commandHistory.push(command);
    historyIndex = commandHistory.length;
  }
  
  // In l·ªánh ra terminal
  const terminalContent = $('#terminalContent');
  const lastLine = terminalContent.children().last();
  if (lastLine.length && lastLine.hasClass('terminal-line')) {
    lastLine.find('.command').text(command);
  }
  
  console.log('[DEBUG] Sending command via socket:', command);
  // G·ª≠i l·ªánh + newline ƒë·ªÉ th·ª±c thi
  socket.emit('terminal_input', {
    shell_id: currentShellId,
    input: command + '\n'
  });
  
  // Reset input
  currentCommand = '';
  cursorPosition = 0;
  $('#commandInput').text('');
  
  console.log('[DEBUG] Command sent successfully');
  // Kh√¥ng in prompt ngay, ƒë·ª£i output t·ª´ shell
}

// Ng·∫Øt k·∫øt n·ªëi shell
function disconnectShell() {
  if (!socket) {
    console.log('[DEBUG] Socket not initialized, cannot disconnect shell');
    return;
  }
  
  if (currentShellId) {
    // G·ª≠i signal ƒë√≥ng shell ho√†n to√†n
    socket.emit('shell_stop', { 
      shell_id: currentShellId,
      action: 'close_completely'
    });
    
    // G·ª≠i AJAX request ƒë·ªÉ ƒë√≥ng shell
    $.ajax({
      url: `/api/shells/${currentShellId}/close`,
      type: 'POST',
      data: JSON.stringify({action: 'close_completely'}),
      contentType: 'application/json',
      success: function(resp) {
        console.log('[DEBUG] Shell closed successfully:', resp);
        printOutput('Shell ƒë√£ ƒë√≥ng ho√†n to√†n.', 'info');
      },
      error: function(xhr) {
        console.error('[DEBUG] Error closing shell:', xhr);
        printOutput('L·ªói khi ƒë√≥ng shell.', 'error');
      }
    });
  }
  
  isConnected = false;
  shellReady = false;
  $('#shellStatus').removeClass('bg-success bg-warning').addClass('bg-secondary').text('Disconnected');
  $('#disconnectShell').prop('disabled', true);
  $('#commandInput').prop('disabled', true);
  $('#sendCommand').prop('disabled', true);
  printOutput('Shell ƒë√£ ƒë√≥ng ho√†n to√†n.');
}

// ==========================
// X·ª≠ l√Ω input t·ª´ terminal th·∫≠t
// ==========================
$('#commandInput').on('keydown', handleKeyDown);

// X·ª≠ l√Ω input text
$('#commandInput').on('input', function() {
  console.log('[DEBUG] Input event triggered');
  currentCommand = $(this).text();
  cursorPosition = currentCommand.length;
});

// X·ª≠ l√Ω click ƒë·ªÉ focus
$('#commandInput').on('click', function() {
  console.log('[DEBUG] Input clicked, focusing...');
  focusInput();
  // Ki·ªÉm tra v√† kh√¥i ph·ª•c terminal state n·∫øu c·∫ßn
  checkAndRestoreTerminalState();
});

// X·ª≠ l√Ω paste
$('#commandInput').on('paste', function(e) {
  e.preventDefault();
  const text = (e.originalEvent || e).clipboardData.getData('text/plain');
  insertText(text);
});

// X·ª≠ l√Ω copy
$('#commandInput').on('copy', function(e) {
  const selection = window.getSelection();
  if (selection.toString()) {
    e.originalEvent.clipboardData.setData('text/plain', selection.toString());
  }
});

// X·ª≠ l√Ω cut
$('#commandInput').on('cut', function(e) {
  const selection = window.getSelection();
  if (selection.toString()) {
    e.originalEvent.clipboardData.setData('text/plain', selection.toString());
    // X√≥a selection
    const range = selection.getRangeAt(0);
    range.deleteContents();
  }
});

// ==========================
// X·ª≠ l√Ω c√°c n√∫t ch·ª©c nƒÉng UI
// ==========================
$('#clearTerminal').click(function() {
  clearTerminal();
});

// Th√™m c√°c ph√≠m t·∫Øt to√†n c·ª•c
$(document).on('keydown', function(e) {
  // Ctrl+L - Clear terminal
  if (e.ctrlKey && e.key === 'l') {
    e.preventDefault();
    clearTerminal();
  }
  
  // Ctrl+Shift+C - Copy t·ª´ terminal
  if (e.ctrlKey && e.shiftKey && e.key === 'C') {
    e.preventDefault();
    const selection = window.getSelection();
    if (selection.toString()) {
      navigator.clipboard.writeText(selection.toString());
    }
  }
  
  // Ctrl+Shift+V - Paste v√†o terminal
  if (e.ctrlKey && e.shiftKey && e.key === 'V') {
    e.preventDefault();
    navigator.clipboard.readText().then(text => {
      insertText(text);
    });
  }
  
  // Focus v√†o terminal khi nh·∫•n Ctrl+`
  if (e.ctrlKey && e.key === '`') {
    e.preventDefault();
    focusInput();
  }
});

$('#fullscreen').click(function() {
  $('.shell-container').toggleClass('fullscreen');
});

$('#disconnectShell').click(function() {
  if (confirm('B·∫°n c√≥ ch·∫Øc mu·ªën ng·∫Øt k·∫øt n·ªëi shell n√†y?')) {
    disconnectShell();
  }
});

$('#toggleShellBtn').click(function() {
  $.ajax({
    url: `/api/shells/${currentShellId}`,
    type: 'GET',
    success: function(resp) {
      if (resp.status === 'success') {
        const status = resp.data.status.toUpperCase();
        if (status === 'CLOSED' || status === 'DISCONNECTED' || status === 'ERROR') {
          // B·∫≠t shell
          console.log('[DEBUG] Starting shell:', currentShellId);
          connectToShell(currentShellId);
          
          // C·∫≠p nh·∫≠t UI ngay l·∫≠p t·ª©c
          $('#shellStatus').removeClass('bg-secondary bg-danger').addClass('bg-warning').text('Starting...');
          updateToggleShellBtn('LISTENING');
          
          // Th√¥ng b√°o cho user
          printOutput('ƒêang kh·ªüi ƒë·ªông shell...', 'info');
        } else {
          // T·∫Øt shell
          if (confirm('B·∫°n c√≥ ch·∫Øc mu·ªën t·∫Øt shell n√†y?')) {
            console.log('[DEBUG] Stopping shell:', currentShellId);
            disconnectShell();
            
            // C·∫≠p nh·∫≠t UI ngay l·∫≠p t·ª©c
            $('#shellStatus').removeClass('bg-success bg-warning').addClass('bg-secondary').text('Stopping...');
            updateToggleShellBtn('CLOSED');
            
            // Th√¥ng b√°o cho user
            printOutput('ƒêang t·∫Øt shell...', 'info');
          }
        }
      }
    },
    error: function(xhr) {
      printOutput(`L·ªói ki·ªÉm tra tr·∫°ng th√°i: ${xhr.responseJSON?.msg || 'Unknown error'}`, 'error');
    }
  });
});

// C·∫≠p nh·∫≠t giao di·ªán n√∫t b·∫≠t/t·∫Øt shell theo tr·∫°ng th√°i
function updateToggleShellBtn(status) {
  status = status.toUpperCase();
  if (status === 'CLOSED' || status === 'DISCONNECTED' || status === 'ERROR') {
    $('#toggleShellBtnText').text('B·∫≠t Shell');
    $('#toggleShellBtn').removeClass('btn-outline-danger').addClass('btn-outline-success');
  } else {
    $('#toggleShellBtnText').text('T·∫Øt Shell');
    $('#toggleShellBtn').removeClass('btn-outline-success').addClass('btn-outline-danger');
  }
}

// Ki·ªÉm tra tr·∫°ng th√°i shell khi load trang
function refreshShellStatus() {
  console.log('[DEBUG] Refreshing shell status for:', currentShellId);
  
  $.ajax({
    url: `/api/shells/${currentShellId}`,
    type: 'GET',
    success: function(resp) {
      if (resp.status === 'success') {
        const status = resp.data.status.toUpperCase();
        console.log('[DEBUG] Current shell status:', status);
        
        // C·∫≠p nh·∫≠t UI theo tr·∫°ng th√°i
        updateToggleShellBtn(status);
        
        if (status === 'CONNECTED') {
          console.log('[DEBUG] Shell is connected, initializing terminal for existing connection');
          $('#shellStatus').removeClass('bg-secondary bg-warning').addClass('bg-success').text('Connected');
          
          // Kh·ªüi t·∫°o terminal cho shell ƒë√£ connected
          initializeTerminalForConnectedShell();
          
          // Tham gia shell room v√† k·∫øt n·ªëi
          connectToShell(currentShellId);
          
        } else if (status === 'LISTENING') {
          console.log('[DEBUG] Shell is listening');
          $('#shellStatus').removeClass('bg-success bg-secondary').addClass('bg-warning').text('Listening');
          isConnected = false;
          shellReady = false;
          
          // Tham gia shell room ƒë·ªÉ nh·∫≠n updates
          socket.emit('join_shell', { shell_id: currentShellId });
          
          // Disable input
          $('#commandInput').prop('disabled', true);
          $('#disconnectShell').prop('disabled', true);
          
          initTerminal();
          printOutput('ƒêang ch·ªù k·∫øt n·ªëi reverse shell...', 'info');
          
        } else if (status === 'CLOSED' || status === 'DISCONNECTED' || status === 'ERROR') {
          console.log('[DEBUG] Shell is closed/disconnected');
          $('#shellStatus').removeClass('bg-success bg-warning').addClass('bg-secondary').text(status);
          isConnected = false;
          shellReady = false;
          
          // Disable input
          $('#commandInput').prop('disabled', true);
          $('#disconnectShell').prop('disabled', true);
          
          initTerminal();
          printOutput('Shell ƒë√£ ƒë√≥ng. Nh·∫•n "B·∫≠t Shell" ƒë·ªÉ k·∫øt n·ªëi l·∫°i.', 'info');
          
        } else {
          console.log('[DEBUG] Unknown shell status:', status);
          $('#shellStatus').removeClass('bg-success bg-warning').addClass('bg-secondary').text(status);
          isConnected = false;
          shellReady = false;
          
          // Disable input
          $('#commandInput').prop('disabled', true);
          $('#disconnectShell').prop('disabled', true);
          
          initTerminal();
          printOutput(`Tr·∫°ng th√°i shell: ${status}`, 'info');
        }
        
        // Tham gia shell room ƒë·ªÉ nh·∫≠n updates realtime (n·∫øu ch∆∞a join)
        if (socket) {
          socket.emit('join_shell', { shell_id: currentShellId });
        } else {
          console.log('[DEBUG] Socket not initialized, cannot join shell room');
        }
        
      } else {
        console.error('[DEBUG] Failed to get shell status:', resp);
        printOutput(`L·ªói l·∫•y tr·∫°ng th√°i shell: ${resp.msg || 'Unknown error'}`, 'error');
        
        // Fallback: tham gia shell room ƒë·ªÉ nh·∫≠n updates
        socket.emit('join_shell', { shell_id: currentShellId });
      }
    },
    error: function(xhr) {
      console.error('[DEBUG] Error refreshing shell status:', xhr);
      printOutput(`L·ªói ki·ªÉm tra tr·∫°ng th√°i: ${xhr.responseJSON?.msg || 'Unknown error'}`, 'error');
      
      // Fallback: tham gia shell room ƒë·ªÉ nh·∫≠n updates
      if (socket) {
        socket.emit('join_shell', { shell_id: currentShellId });
      } else {
        console.log('[DEBUG] Socket not initialized, cannot join shell room');
      }
    }
  });
}

// ==========================
// Kh·ªüi t·∫°o khi load trang
// ==========================
$(document).ready(async function() {
  console.log('[DEBUG] Initializing view-shell page for shell:', currentShellId);
  
  // Reset terminal state khi v√†o l·∫°i
  resetTerminalState();
  
  // Kh·ªüi t·∫°o Socket.IO tr∆∞·ªõc
  await initializeSocketIO();
  
  initTerminal(); // Kh·ªüi t·∫°o terminal
  render_target_info(); // L·∫•y danh s√°ch target
  refreshShellStatus(); // Ki·ªÉm tra tr·∫°ng th√°i shell ban ƒë·∫ßu
  
  // Focus v√†o terminal khi load
  setTimeout(() => {
    focusInput();
    // Debug terminal state sau 2 gi√¢y
    setTimeout(() => {
      debugTerminalState();
    }, 2000);
  }, 500);
  
  // Th√™m tooltip cho ph√≠m t·∫Øt
  $('[data-toggle="tooltip"]').tooltip();
  
  // Th√™m context menu cho terminal
  $('#terminalOutput').on('contextmenu', function(e) {
    e.preventDefault();
    // C√≥ th·ªÉ th√™m context menu ·ªü ƒë√¢y
  });
  
  // Auto-resize terminal khi window resize
  $(window).on('resize', function() {
    const terminalBody = $('#terminalOutput');
    const containerHeight = $('.shell-container').height();
    const headerHeight = $('.terminal-header').outerHeight();
    const inputHeight = $('.terminal-input-area').outerHeight();
    const buttonHeight = $('.p-2').outerHeight();
    
    const newHeight = containerHeight - headerHeight - inputHeight - buttonHeight - 30;
    terminalBody.css('max-height', newHeight + 'px');
  });
  
  // Trigger resize event
  $(window).trigger('resize');
  
  // ==========================
  // RESET TERMINAL STATE
  // ==========================
  function resetTerminalState() {
    console.log('[DEBUG] Resetting terminal state');
    
    // Reset c√°c bi·∫øn global
    isConnected = false;
    shellReady = false;
    outputBuffer = '';
    commandHistory = [];
    historyIndex = -1;
    cursorPosition = 0;
    currentCommand = '';
    selectionStart = 0;
    selectionEnd = 0;
    
    // Reset UI elements
    $('#commandInput').prop('disabled', true);
    $('#disconnectShell').prop('disabled', true);
    $('#shellStatus').removeClass('bg-success bg-warning bg-danger').addClass('bg-secondary').text('Initializing...');
    
    // Clear terminal content
    $('#terminalContent').empty();
    
    // Reset suggestions
    hideSuggestions();
    
    console.log('[DEBUG] Terminal state reset completed');
  }
});

// ==========================
// AUTO-COMPLETION SYSTEM
// ==========================
let commandSuggestions = [];
let currentSuggestionIndex = -1;
let isShowingSuggestions = false;

// Danh s√°ch l·ªánh ph·ªï bi·∫øn
const commonCommands = [
    'ls', 'cd', 'pwd', 'cat', 'grep', 'find', 'ps', 'top', 'kill', 'chmod', 'chown',
    'cp', 'mv', 'rm', 'mkdir', 'rmdir', 'touch', 'nano', 'vim', 'vi', 'less', 'more',
    'head', 'tail', 'wc', 'sort', 'uniq', 'cut', 'awk', 'sed', 'tr', 'tee',
    'ssh', 'scp', 'rsync', 'wget', 'curl', 'ping', 'netstat', 'ifconfig', 'ip',
    'systemctl', 'service', 'apt', 'yum', 'pip', 'python', 'node', 'npm',
    'docker', 'kubectl', 'git', 'tar', 'zip', 'unzip', 'gzip', 'bzip2',
    'whoami', 'id', 'groups', 'passwd', 'sudo', 'su', 'exit', 'logout',
    'history', 'alias', 'export', 'source', 'echo', 'printf', 'read',
    'for', 'while', 'if', 'case', 'function', 'return', 'break', 'continue'
];

// T·∫°o suggestions d·ª±a tr√™n input
function generateSuggestions(input) {
    if (!input.trim()) return [];
    
    const suggestions = [];
    const inputLower = input.toLowerCase();
    
    // T√¨m commands ph√π h·ª£p
    for (const cmd of commonCommands) {
        if (cmd.toLowerCase().startsWith(inputLower)) {
            suggestions.push(cmd);
        }
    }
    
    // Th√™m c√°c suggestions ƒë·∫∑c bi·ªát
    if (inputLower.startsWith('ls')) {
        suggestions.push('ls -la', 'ls -lh', 'ls -R', 'ls -t');
    } else if (inputLower.startsWith('ps')) {
        suggestions.push('ps aux', 'ps -ef', 'ps -eo pid,ppid,cmd');
    } else if (inputLower.startsWith('find')) {
        suggestions.push('find . -name "*.txt"', 'find . -type f', 'find . -mtime -7');
    } else if (inputLower.startsWith('grep')) {
        suggestions.push('grep -r "pattern"', 'grep -i "pattern"', 'grep -v "pattern"');
    }
    
    return suggestions.slice(0, 10); // Gi·ªõi h·∫°n 10 suggestions
}

// Hi·ªÉn th·ªã suggestions
function showSuggestions(suggestions) {
    if (suggestions.length === 0) {
        hideSuggestions();
        return;
    }
    
    // T·∫°o dropdown suggestions
    let dropdown = $('#commandSuggestions');
    if (dropdown.length === 0) {
        dropdown = $('<div id="commandSuggestions" class="command-suggestions"></div>');
        $('.terminal-input-area').append(dropdown);
    }
    
    dropdown.empty();
    suggestions.forEach((suggestion, index) => {
        const item = $(`<div class="suggestion-item" data-index="${index}">${suggestion}</div>`);
        dropdown.append(item);
    });
    
    dropdown.show();
    isShowingSuggestions = true;
    currentSuggestionIndex = -1;
}

// ·∫®n suggestions
function hideSuggestions() {
    $('#commandSuggestions').hide();
    isShowingSuggestions = false;
    currentSuggestionIndex = -1;
}

// Ch·ªçn suggestion
function selectSuggestion(index) {
    const suggestions = $('.suggestion-item');
    if (index >= 0 && index < suggestions.length) {
        suggestions.removeClass('selected');
        suggestions.eq(index).addClass('selected');
        currentSuggestionIndex = index;
    }
}

// √Åp d·ª•ng suggestion
function applySuggestion() {
    if (currentSuggestionIndex >= 0) {
        const suggestion = $('.suggestion-item').eq(currentSuggestionIndex).text();
        currentCommand = suggestion;
        cursorPosition = suggestion.length;
        $('#commandInput').text(suggestion);
        updateCursor();
        hideSuggestions();
    }
}

// X·ª≠ l√Ω Tab cho auto-completion
function handleTabCompletion() {
    const input = $('#commandInput').text();
    const suggestions = generateSuggestions(input);
    
    if (suggestions.length === 1) {
        // N·∫øu ch·ªâ c√≥ 1 suggestion, √°p d·ª•ng lu√¥n
        currentCommand = suggestions[0];
        cursorPosition = suggestions[0].length;
        $('#commandInput').text(suggestions[0]);
        updateCursor();
        hideSuggestions();
    } else if (suggestions.length > 1) {
        // N·∫øu c√≥ nhi·ªÅu suggestions, hi·ªÉn th·ªã dropdown
        showSuggestions(suggestions);
        selectSuggestion(0);
    }
}

// C·∫≠p nh·∫≠t handleKeyDown ƒë·ªÉ h·ªó tr·ª£ auto-completion
const originalHandleKeyDown = window.handleKeyDown;
window.handleKeyDown = function(e) {
    const key = e.key;
    const ctrl = e.ctrlKey;
    const shift = e.shiftKey;
    const alt = e.altKey;
    
    // Tab - Auto-completion
    if (key === 'Tab') {
        e.preventDefault();
        if (isShowingSuggestions) {
            // N·∫øu ƒëang hi·ªÉn th·ªã suggestions, ch·ªçn suggestion ti·∫øp theo
            const suggestions = $('.suggestion-item');
            const nextIndex = (currentSuggestionIndex + 1) % suggestions.length;
            selectSuggestion(nextIndex);
        } else {
            // T·∫°o suggestions m·ªõi
            handleTabCompletion();
        }
        return;
    }
    
    // Enter - √Åp d·ª•ng suggestion ho·∫∑c g·ª≠i l·ªánh
    if (key === 'Enter') {
        if (isShowingSuggestions) {
            e.preventDefault();
            applySuggestion();
            return;
        }
    }
    
    // Escape - ·∫®n suggestions
    if (key === 'Escape') {
        if (isShowingSuggestions) {
            e.preventDefault();
            hideSuggestions();
            return;
        }
    }
    
    // Arrow keys trong suggestions
    if (isShowingSuggestions && (key === 'ArrowUp' || key === 'ArrowDown')) {
        e.preventDefault();
        const suggestions = $('.suggestion-item');
        let newIndex = currentSuggestionIndex;
        
        if (key === 'ArrowUp') {
            newIndex = currentSuggestionIndex <= 0 ? suggestions.length - 1 : currentSuggestionIndex - 1;
        } else {
            newIndex = currentSuggestionIndex >= suggestions.length - 1 ? 0 : currentSuggestionIndex + 1;
        }
        
        selectSuggestion(newIndex);
        return;
    }
    
    // G·ªçi h√†m g·ªëc
    originalHandleKeyDown.call(this, e);
    
    // ·∫®n suggestions khi g√µ
    if (isShowingSuggestions && key.length === 1) {
        hideSuggestions();
    }
};

// Click v√†o suggestion
$(document).on('click', '.suggestion-item', function() {
    const index = parseInt($(this).data('index'));
    selectSuggestion(index);
    applySuggestion();
});

// ==========================
// IMPROVED CURSOR HANDLING
// ==========================
function improvedUpdateCursor() {
    const input = $('#commandInput');
    const text = input.text();
    
    // T·∫°o range ƒë·ªÉ ƒë·∫∑t con tr·ªè ch√≠nh x√°c h∆°n
    const range = document.createRange();
    const selection = window.getSelection();
    
    if (cursorPosition <= text.length) {
        let node = input[0].firstChild;
        if (!node) {
            node = document.createTextNode('');
            input[0].appendChild(node);
        }
        
        // T√≠nh to√°n v·ªã tr√≠ ch√≠nh x√°c h∆°n
        let currentPos = 0;
        let targetNode = node;
        let targetOffset = 0;
        
        // Duy·ªát qua c√°c node con ƒë·ªÉ t√¨m v·ªã tr√≠ ch√≠nh x√°c
        const walker = document.createTreeWalker(
            input[0],
            NodeFilter.SHOW_TEXT,
            null,
            false
        );
        
        while (walker.nextNode()) {
            const textNode = walker.currentNode;
            const textLength = textNode.textContent.length;
            
            if (currentPos + textLength >= cursorPosition) {
                targetNode = textNode;
                targetOffset = cursorPosition - currentPos;
                break;
            }
            currentPos += textLength;
        }
        
        range.setStart(targetNode, targetOffset);
        range.setEnd(targetNode, targetOffset);
        
        selection.removeAllRanges();
        selection.addRange(range);
    }
}

// Override updateCursor function
window.updateCursor = improvedUpdateCursor;
  
  // Trigger resize event
  $(window).trigger('resize');
  
  // ==========================
  // X·ª¨ L√ù BROWSER TAB CLOSE
  // ==========================
  let isPageUnloading = false;
  
  // X·ª≠ l√Ω khi user ƒë√≥ng tab ho·∫∑c r·ªùi kh·ªèi trang
  window.addEventListener('beforeunload', function(e) {
    if (isConnected && !isPageUnloading) {
      isPageUnloading = true;
      
      // Hi·ªÉn th·ªã c·∫£nh b√°o cho user nh∆∞ng KH√îNG ƒë√≥ng shell
      const message = 'Shell ƒëang k·∫øt n·ªëi. Shell s·∫Ω ti·∫øp t·ª•c ch·∫°y trong background. B·∫°n c√≥ th·ªÉ m·ªü l·∫°i tab n√†y ƒë·ªÉ ti·∫øp t·ª•c s·ª≠ d·ª•ng.';
      e.preventDefault();
      e.returnValue = message;
      
      // KH√îNG g·ª≠i signal ƒë√≥ng shell - ƒë·ªÉ shell ti·∫øp t·ª•c ch·∫°y
      console.log('[DEBUG] Tab closing, but shell will continue running in background');
      
      return message;
    }
  });
  
  // X·ª≠ l√Ω khi page visibility thay ƒë·ªïi (tab ·∫©n/hi·ªán)
  document.addEventListener('visibilitychange', function() {
    if (document.hidden && isConnected) {
      console.log('[DEBUG] Page hidden, shell still running in background');
      // C√≥ th·ªÉ th√™m logic ƒë·ªÉ pause shell ho·∫∑c hi·ªÉn th·ªã th√¥ng b√°o
    } else if (!document.hidden && isConnected) {
      console.log('[DEBUG] Page visible, checking terminal state');
      // Ki·ªÉm tra v√† kh√¥i ph·ª•c terminal state khi tab ƒë∆∞·ª£c focus l·∫°i
      setTimeout(() => {
        checkAndRestoreTerminalState();
      }, 500);
    }
  });
  
  // ==========================
  // C·∫¢I THI·ªÜN TR·∫¢I NGHI·ªÜM TERMINAL
  // ==========================
  
  // C·∫£i thi·ªán cursor positioning
  function improvedUpdateCursor() {
    const input = $('#commandInput');
    const text = input.text();
    
    // T·∫°o range ƒë·ªÉ ƒë·∫∑t con tr·ªè ch√≠nh x√°c h∆°n
    const range = document.createRange();
    const selection = window.getSelection();
    
    if (cursorPosition <= text.length) {
      let node = input[0].firstChild;
      if (!node) {
        node = document.createTextNode('');
        input[0].appendChild(node);
      }
      
      // T√≠nh to√°n v·ªã tr√≠ ch√≠nh x√°c h∆°n
      let currentPos = 0;
      let targetNode = node;
      let targetOffset = 0;
      
      // Duy·ªát qua c√°c node con ƒë·ªÉ t√¨m v·ªã tr√≠ ch√≠nh x√°c
      const walker = document.createTreeWalker(
        input[0],
        NodeFilter.SHOW_TEXT,
        null,
        false
      );
      
      while (walker.nextNode()) {
        const textNode = walker.currentNode;
        const textLength = textNode.textContent.length;
        
        if (currentPos + textLength >= cursorPosition) {
          targetNode = textNode;
          targetOffset = cursorPosition - currentPos;
          break;
        }
        currentPos += textLength;
      }
      
      range.setStart(targetNode, targetOffset);
      range.setEnd(targetNode, targetOffset);
      
      selection.removeAllRanges();
      selection.addRange(range);
    }
  }
  
  // C·∫£i thi·ªán selection handling
  function handleSelectionChange() {
    const selection = window.getSelection();
    if (selection.rangeCount > 0) {
      const range = selection.getRangeAt(0);
      const input = $('#commandInput')[0];
      
      if (input.contains(range.startContainer)) {
        // T√≠nh to√°n v·ªã tr√≠ selection trong input
        const startOffset = getTextOffset(input, range.startContainer, range.startOffset);
        const endOffset = getTextOffset(input, range.endContainer, range.endOffset);
        
        selectionStart = startOffset;
        selectionEnd = endOffset;
      }
    }
  }
  
  function getTextOffset(root, node, offset) {
    let totalOffset = 0;
    const walker = document.createTreeWalker(
      root,
      NodeFilter.SHOW_TEXT,
      null,
      false
    );
    
    while (walker.nextNode()) {
      const textNode = walker.currentNode;
      if (textNode === node) {
        return totalOffset + offset;
      }
      totalOffset += textNode.textContent.length;
    }
    return totalOffset;
  }
  
  // C·∫£i thi·ªán copy/paste
  function improvedPaste(e) {
    e.preventDefault();
    const text = (e.originalEvent || e).clipboardData.getData('text/plain');
    
    // X·ª≠ l√Ω paste v·ªõi selection
    if (selectionStart !== selectionEnd) {
      // X√≥a selection tr∆∞·ªõc
      const beforeSelection = currentCommand.slice(0, selectionStart);
      const afterSelection = currentCommand.slice(selectionEnd);
      currentCommand = beforeSelection + text + afterSelection;
      cursorPosition = selectionStart + text.length;
    } else {
      // Paste t·∫°i v·ªã tr√≠ con tr·ªè
      currentCommand = currentCommand.slice(0, cursorPosition) + text + currentCommand.slice(cursorPosition);
      cursorPosition += text.length;
    }
    
    $('#commandInput').text(currentCommand);
    improvedUpdateCursor();
    
    // Reset selection
    selectionStart = selectionEnd = cursorPosition;
  }
  
  // C·∫£i thi·ªán copy
  function improvedCopy(e) {
    const selection = window.getSelection();
    if (selection.toString()) {
      e.originalEvent.clipboardData.setData('text/plain', selection.toString());
    } else {
      // Copy to√†n b·ªô text n·∫øu kh√¥ng c√≥ selection
      e.originalEvent.clipboardData.setData('text/plain', currentCommand);
    }
  }
  
  // C·∫£i thi·ªán cut
  function improvedCut(e) {
    const selection = window.getSelection();
    if (selection.toString()) {
      e.originalEvent.clipboardData.setData('text/plain', selection.toString());
      
      // X√≥a selection
      const beforeSelection = currentCommand.slice(0, selectionStart);
      const afterSelection = currentCommand.slice(selectionEnd);
      currentCommand = beforeSelection + afterSelection;
      cursorPosition = selectionStart;
      
      $('#commandInput').text(currentCommand);
      improvedUpdateCursor();
      
      // Reset selection
      selectionStart = selectionEnd = cursorPosition;
    }
  }
  
  // Th√™m event listeners cho c·∫£i thi·ªán
  $('#commandInput').on('selectionchange', handleSelectionChange);
  $('#commandInput').off('paste').on('paste', improvedPaste);
  $('#commandInput').off('copy').on('copy', improvedCopy);
  $('#commandInput').off('cut').on('cut', improvedCut);
  
  // ==========================
  // PERFORMANCE OPTIMIZATION
  // ==========================
  
  // Debounce resize events
  let resizeTimeout;
  $(window).off('resize').on('resize', function() {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(function() {
      const terminalBody = $('#terminalOutput');
      const containerHeight = $('.shell-container').height();
      const headerHeight = $('.terminal-header').outerHeight();
      const inputHeight = $('.terminal-input-area').outerHeight();
      const buttonHeight = $('.p-2').outerHeight();
      
      const newHeight = containerHeight - headerHeight - inputHeight - buttonHeight - 30;
      terminalBody.css('max-height', newHeight + 'px');
    }, 100);
  });
  
  // Limit terminal output ƒë·ªÉ tr√°nh memory leak
  const MAX_TERMINAL_LINES = 1000;
  function limitTerminalOutput() {
    const terminalContent = $('#terminalContent');
    const lines = terminalContent.children();
    
    if (lines.length > MAX_TERMINAL_LINES) {
      // X√≥a c√°c d√≤ng c≈© nh·∫•t
      const linesToRemove = lines.length - MAX_TERMINAL_LINES;
      lines.slice(0, linesToRemove).remove();
    }
  }
  
  // Override printOutput ƒë·ªÉ limit output
  const originalPrintOutput = window.printOutput;
  window.printOutput = function(output, type = 'normal') {
    originalPrintOutput(output, type);
    limitTerminalOutput();
  };
  
  // ==========================
  // SESSION MANAGEMENT
  // ==========================
  
  // Auto-save session state
  function saveSessionState() {
    const state = {
      commandHistory: commandHistory,
      currentCommand: currentCommand,
      cursorPosition: cursorPosition,
      isConnected: isConnected,
      shellReady: shellReady
    };
    localStorage.setItem('terminal_session_' + currentShellId, JSON.stringify(state));
  }
  
  function loadSessionState() {
    const saved = localStorage.getItem('terminal_session_' + currentShellId);
    if (saved) {
      try {
        const state = JSON.parse(saved);
        commandHistory = state.commandHistory || [];
        currentCommand = state.currentCommand || '';
        cursorPosition = state.cursorPosition || 0;
        // Kh√¥ng restore isConnected v√† shellReady v√¨ c·∫ßn ki·ªÉm tra l·∫°i
      } catch (e) {
        console.error('Error loading session state:', e);
      }
    }
  }
  
  // Auto-save m·ªói 30 gi√¢y
  setInterval(saveSessionState, 30000);
  
  // Load session state khi kh·ªüi t·∫°o
  loadSessionState();
  
  // Cleanup khi r·ªùi kh·ªèi trang
  window.addEventListener('pagehide', function() {
    saveSessionState();
  });
  
  // ==========================
  // RESET TERMINAL STATE
  // ==========================
  function resetTerminalState() {
    console.log('[DEBUG] Resetting terminal state');
    
    // Reset c√°c bi·∫øn global
    isConnected = false;
    shellReady = false;
    outputBuffer = '';
    commandHistory = [];
    historyIndex = -1;
    cursorPosition = 0;
    currentCommand = '';
    selectionStart = 0;
    selectionEnd = 0;
    
    // Reset UI elements
    $('#commandInput').prop('disabled', true);
    $('#disconnectShell').prop('disabled', true);
    $('#shellStatus').removeClass('bg-success bg-warning bg-danger').addClass('bg-secondary').text('Initializing...');
    
    // Clear terminal content
    $('#terminalContent').empty();
    
    // Reset suggestions
    hideSuggestions();
    
    console.log('[DEBUG] Terminal state reset completed');
  }
  
  // Nh·∫≠n th√¥ng b√°o ƒë√£ tham gia shell room
  socket.on('joined_shell', function(data) {
    console.log('[DEBUG] Joined shell room:', data);
    if (data.shell_id === currentShellId) {
      console.log('[DEBUG] Successfully joined shell room for:', currentShellId);
      
      // Ki·ªÉm tra xem shell ƒë√£ connected ch∆∞a
      if (isConnected && shellReady) {
        console.log('[DEBUG] Shell is already connected, initializing terminal');
        initializeTerminalForConnectedShell();
      }
    }
  });

  // H√†m ki·ªÉm tra v√† kh√¥i ph·ª•c terminal state
  function checkAndRestoreTerminalState() {
    console.log('[DEBUG] Checking terminal state...');
    
    // Ki·ªÉm tra xem shell c√≥ ƒëang connected kh√¥ng
    if (isConnected && shellReady) {
      console.log('[DEBUG] Shell is connected and ready, checking terminal state');
      
      // Ki·ªÉm tra xem input c√≥ b·ªã disabled kh√¥ng
      if ($('#commandInput').prop('disabled')) {
        console.log('[DEBUG] Input is disabled, enabling...');
        $('#commandInput').prop('disabled', false);
        $('#disconnectShell').prop('disabled', false);
      }
      
      // Ki·ªÉm tra xem terminal c√≥ n·ªôi dung kh√¥ng
      if (!$('#terminalContent').children().length) {
        console.log('[DEBUG] Terminal is empty, initializing...');
        initializeTerminalForConnectedShell();
      }
      
      // Focus v√†o input
      setTimeout(() => {
        focusInput();
      }, 100);
    }
  }
  
  // Test function ƒë·ªÉ debug terminal state
  function debugTerminalState() {
    console.log('[DEBUG] === TERMINAL STATE DEBUG ===');
    console.log('[DEBUG] isConnected:', isConnected);
    console.log('[DEBUG] shellReady:', shellReady);
    console.log('[DEBUG] currentShellId:', currentShellId);
    console.log('[DEBUG] input disabled:', $('#commandInput').prop('disabled'));
    console.log('[DEBUG] disconnect disabled:', $('#disconnectShell').prop('disabled'));
    console.log('[DEBUG] terminal content children:', $('#terminalContent').children().length);
    console.log('[DEBUG] shell status text:', $('#shellStatus').text());
    console.log('[DEBUG] === END DEBUG ===');
  }
  
  // Expose debug function globally
  window.debugTerminalState = debugTerminalState;
  
  // Force sync shell status function
  function forceSyncShellStatus() {
    console.log('[DEBUG] Force syncing shell status for:', currentShellId);
    
    $.ajax({
      url: `/api/shells/${currentShellId}/force-sync`,
      type: 'POST',
      success: function(resp) {
        if (resp.status === 'success') {
          console.log('[DEBUG] Force sync successful:', resp);
          printOutput(`Shell status synced: ${resp.memory_status} -> ${resp.database_status}`, 'success');
          
          // Refresh shell status sau khi sync
          setTimeout(() => {
            refreshShellStatus();
          }, 1000);
        } else {
          console.error('[DEBUG] Force sync failed:', resp);
          printOutput(`Force sync failed: ${resp.msg}`, 'error');
        }
      },
      error: function(xhr) {
        console.error('[DEBUG] Force sync error:', xhr);
        printOutput(`Force sync error: ${xhr.responseJSON?.msg || 'Unknown error'}`, 'error');
      }
    });
  }
  
  // Expose force sync function globally
  window.forceSyncShellStatus = forceSyncShellStatus;

  // Function ƒë·ªÉ ƒë√≥ng shell ho√†n to√†n
  function closeShellCompletely() {
    if (confirm('B·∫°n c√≥ ch·∫Øc mu·ªën ƒë√≥ng shell ho√†n to√†n?')) {
      disconnectShell();
      printOutput('Shell ƒë√£ ƒë√≥ng ho√†n to√†n.', 'info');
    }
  }

  // Function ƒë·ªÉ hi·ªÉn th·ªã toast notification
  function showToast(type, title, message) {
    // T·∫°o toast container n·∫øu ch∆∞a c√≥
    if (!$('#toastContainer').length) {
      $('body').append('<div id="toastContainer" style="position: fixed; top: 20px; right: 20px; z-index: 9999;"></div>');
    }
    
    const toastId = 'toast_' + Date.now();
    const bgClass = type === 'success' ? 'bg-success' : type === 'error' ? 'bg-danger' : type === 'warning' ? 'bg-warning' : 'bg-info';
    const iconClass = type === 'success' ? 'fas fa-check-circle' : type === 'error' ? 'fas fa-exclamation-circle' : type === 'warning' ? 'fas fa-exclamation-triangle' : 'fas fa-info-circle';
    
    const toastHtml = `
      <div id="${toastId}" class="toast show" role="alert" style="min-width: 300px;">
        <div class="toast-header ${bgClass} text-white">
          <i class="${iconClass} me-2"></i>
          <strong class="me-auto">${title}</strong>
          <button type="button" class="btn-close btn-close-white" data-bs-dismiss="toast"></button>
        </div>
        <div class="toast-body">
          ${message}
        </div>
      </div>
    `;
    
    $('#toastContainer').append(toastHtml);
    
    // T·ª± ƒë·ªông ·∫©n sau 5 gi√¢y
    setTimeout(() => {
      $(`#${toastId}`).fadeOut(500, function() {
        $(this).remove();
      });
    }, 5000);
  }

  // Function ƒë·ªÉ ƒë√≥ng shell ho√†n to√†n
  function closeShellCompletely() {
    if (confirm('B·∫°n c√≥ ch·∫Øc mu·ªën ƒë√≥ng shell ho√†n to√†n?')) {
      disconnectShell();
      printOutput('Shell ƒë√£ ƒë√≥ng ho√†n to√†n.', 'info');
    }
  }
</script>


<script>
  // Toggle show/hide for File Manager include
  $('#toggleFileManagerBtn').on('click', function() {
    const $container = $('#fileManagerContainer');
    const isHidden = $container.is(':hidden');
    $container.toggle();
    $('#toggleFileManagerBtnText').text(isHidden ? '·∫®n Tr√¨nh qu·∫£n l√Ω File' : 'Hi·ªán Tr√¨nh qu·∫£n l√Ω File');
    if (isHidden) {
      const offsetTop = $container.offset() ? $container.offset().top - 80 : 0;
      $('html, body').animate({ scrollTop: offsetTop }, 300);
    }
  });

  $('#updateTargetBtn').click(function() {
    const targetId = $('#targetSelect').val(); // ‚úÖ Fix: targetId -> targetSelect
    const shellId = '{{shell.connection_id}}'; // ‚úÖ Fix: Th√™m quotes cho string
    
    if (!targetId) {
      showToast('error', 'Error', 'Vui l√≤ng ch·ªçn target ƒë·ªÉ li√™n k·∫øt');
      return;
    }

    $.ajax({
      url: `/api/shells/${shellId}/link_target`, // ‚úÖ URL ƒë√£ ƒë√∫ng
      type: 'POST',
      contentType: 'application/json', // ‚úÖ Fix: Th√™m Content-Type
      data: JSON.stringify({ target_id: targetId }), // ‚úÖ Fix: G·ª≠i JSON thay v√¨ form data
      success: function(resp) {
                if (resp.status === 'success') {
          showToast('success', 'Success', 'Target linked successfully');
          showAlertSuccess('Target linked successfully');
          
          // ‚úÖ Ch·ªâ c·∫≠p nh·∫≠t ph·∫ßn UI li√™n quan thay v√¨ reload to√†n trang
          const selectedOption = $('#targetSelect option:selected');
          const targetId = selectedOption.val();
          const targetText = selectedOption.text();
          
          if (targetId) {
            // C·∫≠p nh·∫≠t th√¥ng tin target ƒë√£ li√™n k·∫øt
            $('#linkedTargetInfo').html(`
              <div><strong>Hostname:</strong> <span id="linkedTargetHostname">${targetText.split(' (')[0]}</span></div>
              <div><strong>Target ID:</strong> <a href="/view-target?idtarget=${targetId}" target="_blank" id="linkedTargetId">${targetId}</a></div>
            `);
          }
        } else {
          showToast('error', 'Error', resp.msg);
          showAlertError(resp.msg);
        }
      },
      error: function(xhr, status, error) {
        showToast('error', 'Error', `Failed to link target: ${error}`);
        showAlertError(`Failed to link target: ${error}`);
      }
    });
  });

     // ‚úÖ Au
   // ‚úÖ Save shell notes functionality
   $('#saveNoteBtn').click(function() {
     const shellId = '{{shell.connection_id}}'; 
     const shellNotes = $('#shellNote').val();
     
     $.ajax({
       url: `/api/shells/${shellId}/notes`,
       type: 'POST',
       contentType: 'application/json',
       data: JSON.stringify({ notes: shellNotes }),
       success: function(resp) {
         if (resp.status === 'success') {
           showToast('success', 'Success', 'Shell notes updated successfully');
           showAlertSuccess('Notes successfully updated');
           $('#noteStatus').text('Notes saved successfully').show().fadeOut(3000);
         } else {
           showToast('error', 'Error', resp.msg);
           $('#noteStatus').text('Failed to save notes').removeClass('text-success').addClass('text-danger').show().fadeOut(3000);
         }
       },
       error: function(xhr, status, error) {
         showToast('error', 'Error', `Failed to update shell notes: ${error}`);
         $('#noteStatus').text('Failed to save notes').removeClass('text-success').addClass('text-danger').show().fadeOut(3000);
       }
     });
   });

</script>
{% endblock content %}